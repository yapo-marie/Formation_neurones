{"version":3,"sources":["../../src/helpers/stream.ts"],"sourcesContent":["import {ChatCompletionStream} from 'openai/lib/ChatCompletionStream';\nimport {ChunkStream} from 'src/pipes';\nimport {Stream} from 'openai/streaming';\nimport {ToolCallResult} from 'types/pipes';\n\nexport interface Runner extends ChatCompletionStream<null> {}\n\n/**\n * Converts a ReadableStream into a Runner.\n *\n * @param readableStream - The ReadableStream to convert.\n * @returns The converted Runner.\n */\nexport const fromReadableStream = (readableStream: ReadableStream): Runner => {\n\treturn ChatCompletionStream.fromReadableStream(readableStream);\n};\n\n/**\n * Returns a runner for the given readable stream.\n *\n * @param readableStream - The readable stream to create a runner for.\n * @returns A runner for the given readable stream.\n */\nexport const getRunner = (readableStream: ReadableStream) => {\n\treturn fromReadableStream(readableStream);\n};\n\n/**\n * Retrieves the text part from a given ChunkStream.\n *\n * @param chunk - The ChunkStream object.\n * @returns The text content of the first choice's delta, or an empty string if it doesn't exist.\n */\nexport const getTextPart = (chunk: ChunkStream) => {\n\treturn chunk.choices[0]?.delta?.content || '';\n};\n\n/**\n * Handles the response stream from a given `Response` object.\n *\n * @param {Object} params - The parameters for handling the response stream.\n * @param {Response} params.response - The API response to handle.\n * @param {boolean} params.rawResponse - Optional flag to include raw response headers.\n *\n * @returns {Object} An object containing the processed stream, thread ID, and optionally raw response headers.\n * @returns {ReadableStream<any>} return.stream - The readable stream created from the response.\n * @returns {string | null} return.threadId - The thread ID extracted from the response headers.\n * @returns {Object} [return.rawResponse] - Optional raw response headers.\n * @returns {Record<string, string>} return.rawResponse.headers - The headers from the raw response.\n */\nexport function handleResponseStream({\n\tresponse,\n\trawResponse,\n}: {\n\tresponse: Response;\n\trawResponse?: boolean;\n}): {\n\tstream: any;\n\tthreadId: string | null;\n\trawResponse?: {\n\t\theaders: Record<string, string>;\n\t};\n} {\n\tconst controller = new AbortController();\n\tconst streamSSE = Stream.fromSSEResponse(response, controller);\n\tconst stream = streamSSE.toReadableStream();\n\n\tconst result: {\n\t\tstream: ReadableStream<any>;\n\t\tthreadId: string | null;\n\t\trawResponse?: {\n\t\t\theaders: Record<string, string>;\n\t\t};\n\t} = {\n\t\tstream,\n\t\tthreadId: response.headers.get('lb-thread-id'),\n\t};\n\tif (rawResponse) {\n\t\tresult.rawResponse = {\n\t\t\theaders: Object.fromEntries(response.headers.entries()),\n\t\t};\n\t}\n\treturn result;\n}\n\n/**\n * Retrieves tool calls from a given readable stream.\n *\n * @param stream - The readable stream from which to extract tool calls.\n * @returns A promise that resolves to an array of `ToolCall` objects.\n */\nexport async function getToolsFromStream(\n\tstream: ReadableStream<any>,\n): Promise<ToolCallResult[]> {\n\tlet run = getRunner(stream);\n\tconst {choices} = await run.finalChatCompletion();\n\treturn choices[0].message.tool_calls;\n}\n"],"mappings":";AAAA,SAAQ,4BAA2B;AAEnC,SAAQ,cAAa;AAWd,IAAM,qBAAqB,CAAC,mBAA2C;AAC7E,SAAO,qBAAqB,mBAAmB,cAAc;AAC9D;AAQO,IAAM,YAAY,CAAC,mBAAmC;AAC5D,SAAO,mBAAmB,cAAc;AACzC;AAQO,IAAM,cAAc,CAAC,UAAuB;AAjCnD;AAkCC,WAAO,iBAAM,QAAQ,CAAC,MAAf,mBAAkB,UAAlB,mBAAyB,YAAW;AAC5C;AAeO,SAAS,qBAAqB;AAAA,EACpC;AAAA,EACA;AACD,GASE;AACD,QAAM,aAAa,IAAI,gBAAgB;AACvC,QAAM,YAAY,OAAO,gBAAgB,UAAU,UAAU;AAC7D,QAAM,SAAS,UAAU,iBAAiB;AAE1C,QAAM,SAMF;AAAA,IACH;AAAA,IACA,UAAU,SAAS,QAAQ,IAAI,cAAc;AAAA,EAC9C;AACA,MAAI,aAAa;AAChB,WAAO,cAAc;AAAA,MACpB,SAAS,OAAO,YAAY,SAAS,QAAQ,QAAQ,CAAC;AAAA,IACvD;AAAA,EACD;AACA,SAAO;AACR;AAQA,eAAsB,mBACrB,QAC4B;AAC5B,MAAI,MAAM,UAAU,MAAM;AAC1B,QAAM,EAAC,QAAO,IAAI,MAAM,IAAI,oBAAoB;AAChD,SAAO,QAAQ,CAAC,EAAE,QAAQ;AAC3B;","names":[]}