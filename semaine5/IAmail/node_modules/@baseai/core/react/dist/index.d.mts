import React from 'react';

type MessageRole = 'function' | 'assistant' | 'system' | 'user' | 'tool';
interface Function {
    name: string;
    arguments: string;
}
interface ToolCallResult {
    id: string;
    type: 'function';
    function: Function;
}
interface Message {
    role: MessageRole;
    content: string | null;
    name?: string;
    tool_call_id?: string;
    tool_calls?: ToolCallResult[];
}

interface PipeRequestOptions {
    headers?: Record<string, string> | Headers;
    body?: any;
    data?: any;
    allowEmptySubmit?: boolean;
}
interface UsePipeOptions {
    apiRoute?: string;
    onResponse?: (message: Message) => void;
    onFinish?: (messages: Message[]) => void;
    onConnect?: () => void;
    onError?: (error: Error) => void;
    threadId?: string;
    initialMessages?: Message[];
    stream?: boolean;
}
declare function usePipe({ apiRoute, onResponse, onFinish, onConnect, onError, threadId: initialThreadId, initialMessages, stream, }?: UsePipeOptions): {
    messages: Message[];
    input: string;
    handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
    handleSubmit: (event?: {
        preventDefault?: () => void;
    }, options?: PipeRequestOptions) => Promise<void>;
    isLoading: boolean;
    error: Error | null;
    regenerate: (options?: PipeRequestOptions) => Promise<void>;
    stop: () => void;
    setMessages: (newMessages: Message[]) => void;
    threadId: string | undefined;
    sendMessage: (content: string, options?: PipeRequestOptions) => Promise<void>;
    setInput: React.Dispatch<React.SetStateAction<string>>;
    setThreadId: (newThreadId: string | undefined) => void;
};

export { usePipe };
