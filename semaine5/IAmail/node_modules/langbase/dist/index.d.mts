import { ChatCompletionStream } from 'openai/lib/ChatCompletionStream';
import { ChatCompletionMessageToolCall } from 'openai/resources/chat/completions';

type RetryConfig = {
    limit: number;
    delay: number;
    backoff: 'exponential' | 'linear' | 'fixed';
};
type StepConfig<T = any> = {
    id: string;
    timeout?: number;
    retries?: RetryConfig;
    run: () => Promise<T>;
};
type WorkflowConfig = {
    debug?: boolean;
    name?: string;
    langbase?: Langbase;
};
declare class Workflow {
    private context;
    private debug;
    private name;
    private traceManager?;
    private traceId?;
    private langbase?;
    private originalMethods;
    readonly step: <T = any>(config: StepConfig<T>) => Promise<T>;
    constructor(config: WorkflowConfig);
    /**
     * Replace a method in the Langbase instance with a traced version
     */
    private interceptMethod;
    /**
     * Restore all original methods that were intercepted
     */
    private restoreOriginalMethods;
    /**
     * Intercept all important methods in the Langbase instance
     */
    private setupMethodInterceptors;
    private _step;
    private withTimeout;
    private calculateDelay;
    private sleep;
    end(): Promise<void>;
}

type Role = 'user' | 'assistant' | 'system' | 'tool';
interface RunOptionsBase {
    messages?: Message[];
    variables?: Variable[];
    threadId?: string;
    rawResponse?: boolean;
    runTools?: boolean;
    tools?: Tools[];
    name?: string;
    apiKey?: string;
    llmKey?: string;
    json?: boolean;
    memory?: RuntimeMemory;
}
interface RunOptionsT extends RunOptionsBase {
    stream?: false;
}
interface RunOptionsStreamT extends RunOptionsBase {
    stream: true;
}
interface AgentRunOptionsBase {
    input: string | PromptMessage[];
    instructions?: string | null;
    model: string;
    apiKey: string;
    top_p?: number;
    max_tokens?: number;
    temperature?: number;
    presence_penalty?: number;
    frequency_penalty?: number;
    stop?: string[];
    tools?: Tools[];
    tool_choice?: 'auto' | 'required' | ToolChoice;
    parallel_tool_calls?: boolean;
    mcp_servers?: McpServerSchema[];
    reasoning_effort?: string | null;
    max_completion_tokens?: number;
    response_format?: ResponseFormat;
    customModelParams?: Record<string, any>;
}
type AgentRunOptionsWithoutMcp = Omit<AgentRunOptionsBase, 'mcp_servers'> & {
    stream?: false;
};
type AgentRunOptionsWithMcp = AgentRunOptionsBase & {
    mcp_servers: McpServerSchema[];
    stream: false;
};
type AgentRunOptionsStreamT = Omit<AgentRunOptionsBase, 'mcp_servers'> & {
    stream: true;
};
type AgentRunOptions = AgentRunOptionsWithoutMcp | AgentRunOptionsWithMcp;
type AgentRunOptionsStream = AgentRunOptionsStreamT;
interface McpServerSchema {
    name: string;
    type: 'url';
    url: string;
    authorization_token?: string;
    tool_configuration?: {
        allowed_tools?: string[];
        enabled?: boolean;
    };
    custom_headers?: Record<string, string>;
}
interface Usage {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
}
interface RunResponse {
    completion: string;
    threadId?: string;
    id: string;
    object: string;
    created: number;
    model: string;
    choices: ChoiceGenerate$1[];
    usage: Usage;
    system_fingerprint: string | null;
    rawResponse?: {
        headers: Record<string, string>;
    };
}
interface AgentRunResponse {
    output: string;
    threadId?: string;
    id: string;
    object: string;
    created: number;
    model: string;
    choices: ChoiceGenerate$1[];
    usage: Usage;
    system_fingerprint: string | null;
    rawResponse?: {
        headers: Record<string, string>;
    };
}
interface RunResponseStream {
    stream: ReadableStream<any>;
    threadId: string | null;
    rawResponse?: {
        headers: Record<string, string>;
    };
}
type RunOptions = (RunOptionsT & {
    name: string;
    apiKey?: never;
}) | (RunOptionsT & {
    name?: never;
    apiKey: string;
});
type RunOptionsStream = (RunOptionsStreamT & {
    name: string;
    apiKey?: never;
}) | (RunOptionsStreamT & {
    name?: never;
    apiKey: string;
});
interface Function {
    name: string;
    arguments: string;
}
type RuntimeMemory = {
    name: string;
}[];
interface ToolCall {
    id: string;
    type: 'function';
    function: Function;
}
interface Message {
    role: Role;
    content: string | null;
    name?: string;
    tool_call_id?: string;
    tool_calls?: ToolCall[];
}
interface PromptMessage {
    role: Role;
    content: string | MessageContentType[] | null;
    name?: string;
    tool_call_id?: string;
    tool_calls?: ToolCall[];
}
interface MessageContentType {
    type: string;
    text?: string;
    image_url?: {
        url: string;
        detail?: string;
    };
    cache_control?: {
        type: 'ephemeral';
    };
}
type ResponseFormat = {
    type: 'text';
} | {
    type: 'json_object';
} | {
    type: 'json_schema';
    json_schema: {
        description?: string;
        name: string;
        schema?: Record<string, unknown>;
        strict?: boolean | null;
    };
};
interface ThreadMessage extends Message {
    attachments?: any[];
    metadata?: Record<string, string>;
}
interface Variable {
    name: string;
    value: string;
}
interface ToolChoice {
    type: 'function';
    function: {
        name: string;
    };
}
interface Tools {
    type: 'function';
    function: {
        name: string;
        description?: string;
        parameters?: Record<string, any>;
    };
}
interface PipeBaseOptions {
    name: string;
    description?: string;
    status?: 'public' | 'private';
    upsert?: boolean;
    model?: string;
    stream?: boolean;
    json?: boolean;
    store?: boolean;
    moderate?: boolean;
    top_p?: number;
    max_tokens?: number;
    temperature?: number;
    presence_penalty?: number;
    frequency_penalty?: number;
    stop?: string[];
    tools?: Tools[];
    tool_choice?: 'auto' | 'required' | ToolChoice;
    parallel_tool_calls?: boolean;
    messages?: Message[];
    variables?: Variable[] | Record<string, string>;
    memory?: {
        name: string;
    }[];
    response_format?: ResponseFormat;
}
interface PipeListResponse {
    name: string;
    description: string;
    status: 'public' | 'private';
    owner_login: string;
    url: string;
    model: string;
    stream: boolean;
    json: boolean;
    store: boolean;
    moderate: boolean;
    top_p: number;
    max_tokens: number;
    temperature: number;
    presence_penalty: number;
    frequency_penalty: number;
    stop: string[];
    tool_choice: 'auto' | 'required' | ToolChoice;
    parallel_tool_calls: boolean;
    messages: Message[];
    variables: Variable[] | [];
    tools: Tools[] | [];
    memory: {
        name: string;
    }[] | [];
}
interface PipeBaseResponse {
    name: string;
    description: string;
    status: 'public' | 'private';
    owner_login: string;
    url: string;
    type: 'chat' | 'generate' | 'run';
    api_key: string;
}
interface PipeCreateOptions extends PipeBaseOptions {
}
interface PipeUpdateOptions extends PipeBaseOptions {
}
interface PipeCreateResponse extends PipeBaseResponse {
}
interface PipeUpdateResponse extends PipeBaseResponse {
}
interface MemoryBaseResponse {
    name: string;
    description: string;
    owner_login: string;
    url: string;
}
type EmbeddingModels = 'openai:text-embedding-3-large' | 'cohere:embed-multilingual-v3.0' | 'cohere:embed-multilingual-light-v3.0' | 'google:text-embedding-004';
type ContentType = 'application/pdf' | 'text/plain' | 'text/markdown' | 'text/csv' | 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' | 'application/vnd.ms-excel';
interface MemoryCreateOptions {
    name: string;
    description?: string;
    embedding_model?: EmbeddingModels;
    top_k?: number;
    chunk_size?: number;
    chunk_overlap?: number;
}
interface MemoryDeleteOptions {
    name: string;
}
type FilterOperator = 'Eq' | 'NotEq' | 'In' | 'NotIn' | 'And' | 'Or';
type FilterConnective = 'And' | 'Or';
type FilterValue = string | string[];
type FilterCondition = [string, FilterOperator, FilterValue];
type MemoryFilters = [FilterConnective, MemoryFilters[]] | FilterCondition;
interface MemoryRetrieveOptions {
    query: string;
    memory: {
        name: string;
        filters?: MemoryFilters;
    }[];
    topK?: number;
}
interface MemoryListDocOptions {
    memoryName: string;
}
interface MemoryDeleteDocOptions {
    memoryName: string;
    documentName: string;
}
interface MemoryUploadDocOptions {
    memoryName: string;
    documentName: string;
    meta?: Record<string, string>;
    document: Buffer | File | FormData | ReadableStream;
    contentType: ContentType;
}
interface MemoryRetryDocEmbedOptions {
    memoryName: string;
    documentName: string;
}
interface MemoryCreateResponse extends MemoryBaseResponse {
    chunk_size: number;
    chunk_overlap: number;
    embedding_model: EmbeddingModels;
}
interface MemoryListResponse extends MemoryBaseResponse {
    embeddingModel: EmbeddingModels;
}
interface BaseDeleteResponse {
    success: boolean;
}
interface MemoryDeleteResponse extends BaseDeleteResponse {
}
interface MemoryDeleteDocResponse extends BaseDeleteResponse {
}
interface MemoryRetryDocEmbedResponse extends BaseDeleteResponse {
}
interface MemoryRetrieveResponse {
    text: string;
    similarity: number;
    meta: Record<string, string>;
}
interface MemoryListDocResponse {
    name: string;
    status: 'queued' | 'in_progress' | 'completed' | 'failed';
    status_message: string | null;
    metadata: {
        size: number;
        type: ContentType;
    };
    enabled: boolean;
    chunk_size: number;
    chunk_overlap: number;
    owner_login: string;
}
interface LangbaseOptions {
    apiKey: string;
    baseUrl?: 'https://api.langbase.com' | 'https://eu-api.langbase.com';
}
interface ToolWebSearchOptions {
    query: string;
    service: 'exa';
    totalResults?: number;
    domains?: string[];
    apiKey: string;
}
interface ToolWebSearchResponse {
    url: string;
    content: string;
}
interface ToolCrawlOptions {
    url: string[];
    maxPages?: number;
    apiKey: string;
    service?: 'spider' | 'firecrawl';
}
interface ToolCrawlResponse {
    url: string;
    content: string;
}
interface EmbedOptions {
    chunks: string[];
    embeddingModel?: EmbeddingModels;
}
type EmbedResponse = number[][];
interface ChunkOptions {
    content: string;
    chunkOverlap?: number;
    chunkMaxLength?: number;
}
type ChunkResponse = string[];
type ParseOptions = {
    document: Buffer | File | FormData | ReadableStream;
    documentName: string;
    contentType: ContentType;
};
type ParseResponse = {
    documentName: string;
    content: string;
};
interface ThreadsCreate {
    threadId?: string;
    metadata?: Record<string, string>;
    messages?: ThreadMessage[];
}
interface ThreadsUpdate {
    threadId: string;
    metadata: Record<string, string>;
}
interface ThreadsGet {
    threadId: string;
}
interface DeleteThreadOptions {
    threadId: string;
}
interface ThreadsBaseResponse {
    id: string;
    object: 'thread';
    created_at: number;
    metadata: Record<string, string>;
}
interface ThreadMessagesCreate {
    threadId: string;
    messages: ThreadMessage[];
}
interface ThreadMessagesList {
    threadId: string;
}
interface ThreadMessagesBaseResponse {
    id: string;
    created_at: number;
    thread_id: string;
    content: string;
    role: Role;
    tool_call_id: string | null;
    tool_calls: ToolCall[] | [];
    name: string | null;
    attachments: any[] | [];
    metadata: Record<string, string> | {};
}
interface ChoiceGenerate$1 {
    index: number;
    message: Message;
    logprobs: boolean | null;
    finish_reason: string;
}
interface ChoiceGenerate$1 {
    index: number;
    message: Message;
    logprobs: boolean | null;
    finish_reason: string;
}
declare class Langbase {
    private request;
    private apiKey;
    private baseUrl;
    pipes: {
        list: () => Promise<PipeListResponse[]>;
        create: (options: PipeCreateOptions) => Promise<PipeCreateResponse>;
        update: (options: PipeUpdateOptions) => Promise<PipeUpdateResponse>;
        run: {
            (options: RunOptionsStream): Promise<RunResponseStream>;
            (options: RunOptions): Promise<RunResponse>;
        };
    };
    /**
     * @deprecated This method is deprecated and will be removed in a future version.
     *
     * Please use `langbase.pipes`
     */
    pipe: {
        list: () => Promise<PipeListResponse[]>;
        create: (options: PipeCreateOptions) => Promise<PipeCreateResponse>;
        update: (options: PipeUpdateOptions) => Promise<PipeUpdateResponse>;
        run: {
            (options: RunOptionsStream): Promise<RunResponseStream>;
            (options: RunOptions): Promise<RunResponse>;
        };
    };
    memories: {
        create: (options: MemoryCreateOptions) => Promise<MemoryCreateResponse>;
        delete: (options: MemoryDeleteOptions) => Promise<MemoryDeleteResponse>;
        retrieve: (options: MemoryRetrieveOptions) => Promise<MemoryRetrieveResponse[]>;
        list: () => Promise<MemoryListResponse[]>;
        documents: {
            list: (options: MemoryListDocOptions) => Promise<MemoryListDocResponse[]>;
            delete: (options: MemoryDeleteDocOptions) => Promise<MemoryDeleteDocResponse>;
            upload: (options: MemoryUploadDocOptions) => Promise<Response>;
            embeddings: {
                retry: (options: MemoryRetryDocEmbedOptions) => Promise<MemoryRetryDocEmbedResponse>;
            };
        };
    };
    /**
     * @deprecated This method is deprecated and will be removed in a future version.
     *
     * Please use `langbase.memories`
     */
    memory: {
        create: (options: MemoryCreateOptions) => Promise<MemoryCreateResponse>;
        delete: (options: MemoryDeleteOptions) => Promise<MemoryDeleteResponse>;
        retrieve: (options: MemoryRetrieveOptions) => Promise<MemoryRetrieveResponse[]>;
        list: () => Promise<MemoryListResponse[]>;
        documents: {
            list: (options: MemoryListDocOptions) => Promise<MemoryListDocResponse[]>;
            delete: (options: MemoryDeleteDocOptions) => Promise<MemoryDeleteDocResponse>;
            upload: (options: MemoryUploadDocOptions) => Promise<Response>;
            embedding: {
                retry: (options: MemoryRetryDocEmbedOptions) => Promise<MemoryRetryDocEmbedResponse>;
            };
        };
    };
    threads: {
        create: (options: ThreadsCreate) => Promise<ThreadsBaseResponse>;
        update: (options: ThreadsUpdate) => Promise<ThreadsBaseResponse>;
        get: (options: ThreadsGet) => Promise<ThreadsBaseResponse>;
        delete: (options: DeleteThreadOptions) => Promise<{
            success: boolean;
        }>;
        append: (options: ThreadMessagesCreate) => Promise<ThreadMessagesBaseResponse[]>;
        messages: {
            list: (options: ThreadMessagesList) => Promise<ThreadMessagesBaseResponse[]>;
        };
    };
    /**
     * @deprecated This method is deprecated and will be removed in a future version.
     *
     * Please use `langbase.tools`
     */
    tool: {
        crawl: (options: ToolCrawlOptions) => Promise<ToolCrawlResponse[]>;
        webSearch: (options: ToolWebSearchOptions) => Promise<ToolWebSearchResponse[]>;
    };
    tools: {
        crawl: (options: ToolCrawlOptions) => Promise<ToolCrawlResponse[]>;
        webSearch: (options: ToolWebSearchOptions) => Promise<ToolWebSearchResponse[]>;
    };
    embed: (options: EmbedOptions) => Promise<EmbedResponse>;
    chunk: (options: ChunkOptions) => Promise<ChunkResponse>;
    chunker: (options: ChunkOptions) => Promise<ChunkResponse>;
    parse: (options: ParseOptions) => Promise<ParseResponse>;
    parser: (options: ParseOptions) => Promise<ParseResponse>;
    agent: {
        run: {
            (options: AgentRunOptionsStream): Promise<RunResponseStream>;
            (options: AgentRunOptions): Promise<AgentRunResponse>;
        };
    };
    workflow: (config: {
        debug?: boolean;
        name?: string;
    }) => Workflow;
    traces: {
        create: (trace: any) => Promise<any>;
    };
    constructor(options?: LangbaseOptions);
    private runPipe;
    /**
     * Creates a new pipe on Langbase.
     *
     * @param {PipeCreateOptions} options - The options for creating the pipe.
     * @returns {Promise<PipeCreateResponse>} A promise that resolves to the response of the pipe creation.
     */
    private createPipe;
    /**
     * Updates a pipe on Langbase.
     *
     * @param {PipeUpdateOptions} options - The options for updating the pipe.
     * @returns {Promise<PipeUpdateResponse>} A promise that resolves to the response of the update operation.
     */
    private updatePipe;
    /**
     * Retrieves a list of pipes.
     *
     * @returns {Promise<PipeListResponse[]>} A promise that resolves to an array of PipeListResponse objects.
     */
    private listPipe;
    /**
     * Creates a new memory on Langbase.
     *
     * @param {MemoryCreateOptions} options - The options to create the memory instance.
     * @param {string} options.name - The name of the memory.
     * @param {string} options.description - The description of the memory.
     * @returns {Promise<MemoryCreateResponse>} A promise that resolves to the response of the memory creation.
     */
    private createMemory;
    /**
     * Retrieves a list of all memories on Langbase.
     *
     * @returns {Promise<MemoryListResponse[]>} A promise that resolves to an array of memory list responses.
     */
    private listMemory;
    /**
     * Deletes a memory on Langbase.
     *
     * @param {MemoryDeleteOptions} options - The options for deleting the memory resource.
     * @param {string} options.name - The name of the memory to delete.
     * @returns {Promise<MemoryDeleteResponse>} A promise that resolves to the response of the delete operation.
     */
    private deleteMemory;
    /**
     * Retrieves similar text from the memory.
     *
     * @param {MemoryRetrieveOptions} options - The options to use for retrieving memory data.
     * @param {string} options.query - The query text to search for.
     * @param {object[]} options.memory - The memory to search in.
     * @param {number} [options.topK] - The number of similar texts to retrieve.
     * @returns A promise that resolves to an array of `MemoryRetrieveResponse` objects.
     */
    private retrieveMemory;
    /**
     * Retrieves a list of documents inside a memory.
     *
     * @param {MemoryListDocOptions} options - The options for listing documents, including the memory name.
     * @param {string} options.memoryName - The name of the memory to list documents from.
     * @returns A promise that resolves to an array of `MemoryListDocResponse` objects.
     */
    private listDocs;
    /**
     * Deletes a document from a memory.
     *
     * @param {MemoryDeleteDocOptions} options - The options for deleting the document.
     * @param {string} options.memoryName - The name of the memory to delete the document from.
     * @param {string} options.documentName - The name of the document to delete.
     * @returns A promise that resolves to a `MemoryDeleteDocResponse` indicating the result of the delete operation.
     */
    private deleteDoc;
    /**
     * Uploads a document to the memory.
     *
     * @param {MemoryUploadDocOptions} options - The options for uploading the document.
     * @param {string} options.memoryName - The name of the memory to upload the document to.
     * @param {string} options.fileName - The name of the file being uploaded.
     * @param {object} [options.meta] - Optional metadata associated with the document.
     * @param {string} options.contentType - The MIME type of the file being uploaded.
     * @param {Blob | Buffer} options.file - The file content to be uploaded.
     * @returns {Promise<Response>} The response from the upload request.
     * @throws Will throw an error if the upload fails.
     */
    private uploadDocs;
    /**
     * Retries the embedding process for a specific document in memory.
     *
     * @param options - The options required to retry the document embedding.
     * @param options.memoryName - The name of the memory containing the document.
     * @param options.documentName - The name of the document to retry embedding for.
     * @returns A promise that resolves to the response of the retry operation.
     */
    private retryDocEmbed;
    /**
     * Performs a web search using the Langbase API.
     *
     * @param options - Web search configuration options
     * @param options.apiKey - Optional API key for web search authentication
     * @returns Promise that resolves to an array of web search results
     */
    private webSearch;
    /**
     * Performs a web crawls on target websites using the Langbase API.
     *
     * @param options - Crawl configuration options
     * @returns An array of responses containing data from the crawl operation.
     */
    private webCrawl;
    /**
     * Generates embeddings for the given input using the LangBase API.
     *
     * @param options - Embed options
     * @returns Promise that resolves to the embedding response containing vector representations
     */
    private generateEmbeddings;
    /**
     * Splits a given document into multiple chunks using the Langbase API.
     *
     * @param options - The chunking options.
     * @param options.document - The document to be chunked.
     * @param options.chunk_max_length - An optional maximum length for each chunk.
     * @param options.chunk_overlap - An optional number of overlapping characters between chunks.
     * @param options.separator - An optional separator used to split the document.
     * @returns A promise that resolves to the chunked document response.
     */
    private chunkDocument;
    /**
     * Parses a document using the Langbase API.
     *
     * @param options - The options for parsing the document
     * @param options.document - The document to be parsed
     * @param options.documentName - The name of the document
     * @param options.contentType - The content type of the document
     *
     * @returns A promise that resolves to the parse response from the API
     *
     * @throws {Error} If the API request fails
     */
    private parseDocument;
    /**
     * Creates a new thread with specified options.
     * @param {ThreadsCreate} options - The options object containing thread creation parameters.
     * @returns {Promise<ThreadsBaseResponse>} A promise that resolves to the created thread response.
     * @private
     */
    private createThread;
    /**
     * Updates an existing thread with the provided options.
     *
     * @param options - The options to update the thread with
     * @param options.threadId - The ID of the thread to update
     * @returns A promise that resolves to the updated thread response
     * @throws {Error} If the request fails
     */
    private updateThread;
    /**
     * Retrieves a thread by its ID.
     * @param {ThreadsGet} options - The options object containing the thread ID.
     * @param {string} options.threadId - The unique identifier of the thread to retrieve.
     * @returns {Promise<ThreadsBaseResponse>} A promise that resolves to the thread data.
     */
    private getThread;
    private deleteThread;
    private appendThreadMessages;
    private listThreadMessages;
    private runAgent;
    /**
     * Creates a new trace on Langbase.
     *
     * @param {any} trace - The trace data to send.
     * @returns {Promise<any>} A promise that resolves to the response of the trace creation.
     */
    private createTrace;
}

declare class Stream<Item> implements AsyncIterable<Item> {
    private iterator;
    controller: AbortController;
    constructor(iterator: () => AsyncIterator<Item>, controller: AbortController);
    /**
     * Creates a stream of AsyncIterator from a Server-Sent Events (SSE) response.
     *
     * @template Item - The type of items in the stream.
     * @param {Response} response - The SSE response object.
     * @param {AbortController} controller - The abort controller used to cancel the ongoing request.
     * @returns {Stream<AsyncIterator<Item, any, undefined>>} - The stream created from the SSE response.
     * @throws {Error} - If the stream has already been consumed.
     */
    static fromSSEResponse<Item>(response: Response, controller: AbortController): Stream<Item>;
    /**
     * Generates a Stream from a newline-separated ReadableStream
     * where each item is a JSON value.
     *
     * @template Item - The type of items in the stream.
     * @param {ReadableStream} readableStream - The readable stream to create the stream from.
     * @param {AbortController} controller - The abort controller to control the stream.
     * @returns {Stream<Item>} - The created stream.
     */
    static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController): Stream<Item>;
    [Symbol.asyncIterator](): AsyncIterator<Item>;
    /**
     * Splits the stream into two streams which can be
     * independently read from at different speeds.
     */
    tee(): [Stream<Item>, Stream<Item>];
    /**
     * Converts this stream to a newline-separated ReadableStream of
     * JSON stringified values in the stream which can be turned back into a Stream with `Stream.fromReadableStream()`.
     */
    toReadableStream(): ReadableStream;
}

interface GenerateOptions {
    messages?: Message[];
    variables?: Variable[];
    threadId?: string;
    chat?: boolean;
}
interface StreamOptions {
    messages?: Message[];
    variables?: Variable[];
    threadId?: string | null;
    chat?: boolean;
}
interface ChoiceGenerate {
    index: number;
    message: Message;
    logprobs: boolean | null;
    finish_reason: string;
}
interface ChoiceStream$1 {
    index: number;
    delta: Delta$1;
    logprobs: boolean | null;
    finish_reason: string;
}
interface Delta$1 {
    role?: Role;
    content?: string;
    tool_calls?: ToolCall[];
}
interface GenerateResponse {
    completion: string;
    threadId?: string;
    id: string;
    object: string;
    created: number;
    model: string;
    choices: ChoiceGenerate[];
    usage: Usage;
    system_fingerprint: string | null;
}
type StreamText = Stream<StreamChunk>;
interface StreamResponse {
    stream: StreamText;
    threadId: string | null;
}
interface StreamChunk {
    id: string;
    object: string;
    created: number;
    model: string;
    choices: ChoiceStream$1[];
}
interface PipeOptions {
    apiKey: string;
    baseUrl?: string;
    name?: string;
}
declare class Pipe {
    private request;
    constructor(options: PipeOptions);
    /**
     * @deprecated This method is deprecated and will be removed in a future version.
     *
     * Please use `langbase.pipes.run()` instead
     * @see https://langbase.com/docs/sdk/pipe/run
     */
    generateText(options: GenerateOptions): Promise<GenerateResponse>;
    /**
     * @deprecated This method is deprecated and will be removed in a future version.
     *
     * Please use `langbase.pipes.run()` instead
     * @see https://langbase.com/docs/sdk/pipe/run
     */
    streamText(options: StreamOptions): Promise<StreamResponse>;
}
/**
 * Print stream to standard output (console).
 * @param stream The stream to print
 */
declare const printStreamToStdout: (stream: StreamText) => Promise<void>;

interface Runner extends ChatCompletionStream {
}
interface ToolCallResult extends ChatCompletionMessageToolCall {
}
type MessageRole = 'function' | 'assistant' | 'system' | 'user' | 'tool';
interface Delta {
    role?: MessageRole;
    content?: string;
    tool_calls?: ToolCallResult[];
}
interface ChoiceStream {
    index: number;
    delta: Delta;
    logprobs: boolean | null;
    finish_reason: string;
}
interface ChunkStream {
    id: string;
    object: string;
    created: number;
    model: string;
    choices: ChoiceStream[];
}
/**
 * Converts a ReadableStream into a Runner.
 *
 * @param readableStream - The ReadableStream to convert.
 * @returns The converted Runner.
 */
declare const fromReadableStream: (readableStream: ReadableStream) => Runner;
/**
 * Returns a runner for the given readable stream.
 *
 * @param readableStream - The readable stream to create a runner for.
 * @returns A runner for the given readable stream.
 */
declare const getRunner: (readableStream: ReadableStream) => Runner;
/**
 * Retrieves the text part from a given ChunkStream.
 *
 * @param chunk - The ChunkStream object.
 * @returns The text content of the first choice's delta, or an empty string if it doesn't exist.
 */
declare const getTextPart: (chunk: ChunkStream) => string;
/**
 * Handles the response stream from a given `Response` object.
 *
 * @param {Object} params - The parameters for handling the response stream.
 * @param {Response} params.response - The API response to handle.
 * @param {boolean} params.rawResponse - Optional flag to include raw response headers.
 *
 * @returns {Object} An object containing the processed stream, thread ID, and optionally raw response headers.
 * @returns {ReadableStream<any>} return.stream - The readable stream created from the response.
 * @returns {string | null} return.threadId - The thread ID extracted from the response headers.
 * @returns {Object} [return.rawResponse] - Optional raw response headers.
 * @returns {Record<string, string>} return.rawResponse.headers - The headers from the raw response.
 */
declare function handleResponseStream({ response, rawResponse, }: {
    response: Response;
    rawResponse?: boolean;
}): {
    stream: any;
    threadId: string | null;
    rawResponse?: {
        headers: Record<string, string>;
    };
};
/**
 * Retrieves tool calls from a given readable stream.
 *
 * @param stream - The readable stream from which to extract tool calls.
 * @returns A promise that resolves to an array of `ToolCall` objects.
 */
declare function getToolsFromStream(stream: ReadableStream<any>): Promise<ChatCompletionMessageToolCall[]>;
/**
 * Retrieves tools from a readable stream asynchronously.
 *
 * @param stream - The readable stream to extract tools from
 * @returns A promise that resolves with the tools extracted from the stream
 */
declare function getToolsFromRunStream(stream: ReadableStream<any>): Promise<ChatCompletionMessageToolCall[]>;
/**
 * Extracts tool calls from non-stream response.
 * @param response - The run response object
 * @returns A promise that resolves to an array of tool calls. Returns empty array if no tools are present.
 */
declare function getToolsFromRun(response: RunResponse): Promise<ChatCompletionMessageToolCall[]>;

export { type AgentRunOptions, type AgentRunOptionsBase, type AgentRunOptionsStream, type AgentRunOptionsStreamT, type AgentRunOptionsWithMcp, type AgentRunOptionsWithoutMcp, type AgentRunResponse, type BaseDeleteResponse, type ChunkOptions, type ChunkResponse, type ChunkStream, type ContentType, type DeleteThreadOptions, type EmbedOptions, type EmbedResponse, type EmbeddingModels, type Function, type GenerateOptions, type GenerateResponse, Langbase, type LangbaseOptions, type McpServerSchema, type MemoryCreateOptions, type MemoryCreateResponse, type MemoryDeleteDocOptions, type MemoryDeleteDocResponse, type MemoryDeleteOptions, type MemoryDeleteResponse, type MemoryListDocOptions, type MemoryListDocResponse, type MemoryListResponse, type MemoryRetrieveOptions, type MemoryRetrieveResponse, type MemoryRetryDocEmbedOptions, type MemoryRetryDocEmbedResponse, type MemoryUploadDocOptions, type Message, type MessageContentType, type MessageRole, type ParseOptions, type ParseResponse, Pipe, type PipeCreateOptions, type PipeCreateResponse, type PipeListResponse, type PipeOptions, type PipeUpdateOptions, type PipeUpdateResponse, type PromptMessage, type ResponseFormat, type Role, type RunOptions, type RunOptionsBase, type RunOptionsStream, type RunOptionsStreamT, type RunOptionsT, type RunResponse, type RunResponseStream, type Runner, type RuntimeMemory, type StreamChunk, type StreamOptions, type StreamResponse, type StreamText, type ThreadMessage, type ThreadMessagesBaseResponse, type ThreadMessagesCreate, type ThreadMessagesList, type ThreadsBaseResponse, type ThreadsCreate, type ThreadsGet, type ThreadsUpdate, type ToolCall, type ToolCallResult, type ToolCrawlOptions, type ToolCrawlResponse, type ToolWebSearchOptions, type ToolWebSearchResponse, type Tools, type Usage, type Variable, Workflow, fromReadableStream, getRunner, getTextPart, getToolsFromRun, getToolsFromRunStream, getToolsFromStream, handleResponseStream, printStreamToStdout };
