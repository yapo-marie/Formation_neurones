{"version":3,"sources":["../src/index.ts","../src/lib/utils/doc-to-formdata.ts","../src/data/constants.ts","../src/common/errors.ts","../src/common/stream.ts","../src/common/request.ts","../src/langbase/trace.ts","../src/langbase/workflows.ts","../src/langbase/langbase.ts","../src/pipes/pipes.ts","../src/lib/helpers/index.ts"],"sourcesContent":["export * from './langbase/langbase';\nexport * from './pipes/pipes';\nexport * from './lib/helpers';\nexport * from './langbase/workflows';\n","/**\n * Converts various document formats to FormData.\n *\n * @param options - The conversion options\n * @param options.document - The document to convert. Can be Buffer, File, FormData or ReadableStream\n * @param options.documentName - The name of the document\n * @param options.contentType - The MIME type of the document\n *\n * @returns A Promise that resolves to FormData containing the document\n *\n * @example\n * ```ts\n * const buffer = Buffer.from('Hello World');\n * const formData = await convertDocToFormData({\n *   document: buffer,\n *   documentName: 'hello.txt',\n *   contentType: 'text/plain'\n * });\n * ```\n */\nexport async function convertDocToFormData(options: {\n\tdocument: Buffer | File | FormData | ReadableStream;\n\tdocumentName: string;\n\tcontentType: string;\n}) {\n\tlet formData = new FormData();\n\n\tif (options.document instanceof Buffer) {\n\t\tconst documentBlob = new Blob([options.document], {\n\t\t\ttype: options.contentType,\n\t\t});\n\t\tformData.append('document', documentBlob, options.documentName);\n\t} else if (options.document instanceof File) {\n\t\tformData.append('document', options.document, options.documentName);\n\t} else if (options.document instanceof FormData) {\n\t\tformData = options.document;\n\t} else if (options.document instanceof ReadableStream) {\n\t\tconst chunks: Uint8Array[] = [];\n\t\tconst reader = options.document.getReader();\n\n\t\twhile (true) {\n\t\t\tconst {done, value} = await reader.read();\n\t\t\tif (done) break;\n\t\t\tchunks.push(value);\n\t\t}\n\n\t\tconst documentBlob = new Blob(chunks, {type: options.contentType});\n\t\tformData.append('document', documentBlob, options.documentName);\n\t}\n\n\tformData.append('documentName', options.documentName);\n\n\treturn formData;\n}\n","export const GENERATION_ENDPOINTS = [\n\t'/v1/pipes/run',\n\t'/beta/chat',\n\t'/beta/generate',\n\t'/v1/agent/run',\n];\n","import {Headers} from './../../types'; // Ensure this import is correct\n\nexport class APIError extends Error {\n\treadonly status: number | undefined;\n\treadonly headers: Headers | undefined;\n\treadonly error: Object | undefined;\n\n\treadonly code: string | null | undefined;\n\treadonly param: string | null | undefined;\n\treadonly type: string | undefined;\n\n\treadonly request_id: string | null | undefined;\n\n\tconstructor(\n\t\tstatus: number | undefined,\n\t\terror: Object | undefined,\n\t\tmessage: string | undefined,\n\t\theaders: Headers | undefined,\n\t) {\n\t\tsuper(APIError.makeMessage(status, error, message));\n\t\tthis.status = status;\n\t\tthis.headers = headers;\n\t\tthis.request_id = headers?.['lb-request-id'];\n\n\t\tconst data = error as Record<string, any>;\n\t\tthis.error = data;\n\t\tthis.code = data?.['code'];\n\t\tthis.status = data?.['status'];\n\t\t// this.param = data?.['param'];\n\t\t// this.type = data?.['type'];\n\t}\n\n\tprivate static makeMessage(\n\t\tstatus: number | undefined,\n\t\terror: any,\n\t\tmessage: string | undefined,\n\t): string {\n\t\tconst msg = error?.message\n\t\t\t? typeof error.message === 'string'\n\t\t\t\t? error.message\n\t\t\t\t: JSON.stringify(error.message)\n\t\t\t: error\n\t\t\t\t? JSON.stringify(error)\n\t\t\t\t: message;\n\n\t\tif (status && msg) {\n\t\t\treturn `${status} ${msg}`;\n\t\t}\n\t\tif (status) {\n\t\t\treturn `${status} status code (no body)`;\n\t\t}\n\t\tif (msg) {\n\t\t\treturn msg;\n\t\t}\n\t\treturn '(no status code or body)';\n\t}\n\n\tstatic generate(\n\t\tstatus: number | undefined,\n\t\terrorResponse: Object | undefined,\n\t\tmessage: string | undefined,\n\t\theaders: Headers | undefined,\n\t): APIError {\n\t\tif (!status) {\n\t\t\treturn new APIConnectionError({\n\t\t\t\tcause:\n\t\t\t\t\terrorResponse instanceof Error ? errorResponse : undefined,\n\t\t\t});\n\t\t}\n\n\t\tconst error = (errorResponse as Record<string, any>)?.['error'];\n\n\t\tswitch (status) {\n\t\t\tcase 400:\n\t\t\t\treturn new BadRequestError(status, error, message, headers);\n\t\t\tcase 401:\n\t\t\t\treturn new AuthenticationError(status, error, message, headers);\n\t\t\tcase 403:\n\t\t\t\treturn new PermissionDeniedError(\n\t\t\t\t\tstatus,\n\t\t\t\t\terror,\n\t\t\t\t\tmessage,\n\t\t\t\t\theaders,\n\t\t\t\t);\n\t\t\tcase 404:\n\t\t\t\treturn new NotFoundError(status, error, message, headers);\n\t\t\tcase 409:\n\t\t\t\treturn new ConflictError(status, error, message, headers);\n\t\t\tcase 422:\n\t\t\t\treturn new UnprocessableEntityError(\n\t\t\t\t\tstatus,\n\t\t\t\t\terror,\n\t\t\t\t\tmessage,\n\t\t\t\t\theaders,\n\t\t\t\t);\n\t\t\tcase 429:\n\t\t\t\treturn new RateLimitError(status, error, message, headers);\n\t\t\tdefault:\n\t\t\t\treturn status >= 500\n\t\t\t\t\t? new InternalServerError(status, error, message, headers)\n\t\t\t\t\t: new APIError(status, error, message, headers);\n\t\t}\n\t}\n}\n\nexport class APIConnectionError extends APIError {\n\toverride readonly status: undefined = undefined;\n\n\tconstructor({message, cause}: {message?: string; cause?: Error}) {\n\t\tsuper(undefined, undefined, message || 'Connection error.', undefined);\n\t\tif (cause) (this as Error).cause = cause;\n\t}\n}\n\nexport class APIConnectionTimeoutError extends APIConnectionError {\n\tconstructor({message}: {message?: string} = {}) {\n\t\tsuper({message: message ?? 'Request timed out.'});\n\t}\n}\n\nexport class BadRequestError extends APIError {\n\toverride readonly status: 400 = 400;\n}\n\nexport class AuthenticationError extends APIError {\n\toverride readonly status: 401 = 401;\n}\n\nexport class PermissionDeniedError extends APIError {\n\toverride readonly status: 403 = 403;\n}\n\nexport class NotFoundError extends APIError {\n\toverride readonly status: 404 = 404;\n}\n\nexport class ConflictError extends APIError {\n\toverride readonly status: 409 = 409;\n}\n\nexport class UnprocessableEntityError extends APIError {\n\toverride readonly status: 422 = 422;\n}\n\nexport class RateLimitError extends APIError {\n\toverride readonly status: 429 = 429;\n}\n\nexport class InternalServerError extends APIError {}\n","type Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\nexport type ServerSentEvent = {\n\tevent: string | null;\n\tdata: string;\n\traw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n\tcontroller: AbortController;\n\n\tconstructor(\n\t\tprivate iterator: () => AsyncIterator<Item>,\n\t\tcontroller: AbortController,\n\t) {\n\t\tthis.controller = controller;\n\t}\n\n\t/**\n\t * Creates a stream of AsyncIterator from a Server-Sent Events (SSE) response.\n\t *\n\t * @template Item - The type of items in the stream.\n\t * @param {Response} response - The SSE response object.\n\t * @param {AbortController} controller - The abort controller used to cancel the ongoing request.\n\t * @returns {Stream<AsyncIterator<Item, any, undefined>>} - The stream created from the SSE response.\n\t * @throws {Error} - If the stream has already been consumed.\n\t */\n\tstatic fromSSEResponse<Item>(\n\t\tresponse: Response,\n\t\tcontroller: AbortController,\n\t) {\n\t\tlet consumed = false;\n\n\t\tasync function* iterator(): AsyncIterator<Item, any, undefined> {\n\t\t\tif (consumed) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot iterate over a consumed stream, use `.tee()` to split the stream.',\n\t\t\t\t);\n\t\t\t}\n\t\t\tconsumed = true;\n\t\t\tlet done = false;\n\t\t\ttry {\n\t\t\t\tfor await (const sse of _iterSSEMessages(\n\t\t\t\t\tresponse,\n\t\t\t\t\tcontroller,\n\t\t\t\t)) {\n\t\t\t\t\tif (done) continue;\n\n\t\t\t\t\tif (sse.data.startsWith('[DONE]')) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sse.event === null) {\n\t\t\t\t\t\tlet data;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdata = JSON.parse(sse.data);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t`Could not parse message into JSON:`,\n\t\t\t\t\t\t\t\tsse.data,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconsole.error(`From chunk:`, sse.raw);\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (data && data.error) {\n\t\t\t\t\t\t\tthrow new Error(data.error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tyield data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet data;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdata = JSON.parse(sse.data);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t`Could not parse message into JSON:`,\n\t\t\t\t\t\t\t\tsse.data,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconsole.error(`From chunk:`, sse.raw);\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: Is this where the error should be thrown?\n\t\t\t\t\t\tif (sse.event == 'error') {\n\t\t\t\t\t\t\tthrow new Error(data.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tyield {event: sse.event, data: data} as any;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t} catch (e) {\n\t\t\t\t// If the user calls `stream.controller.abort()`, we should exit without throwing.\n\t\t\t\tif (e instanceof Error && e.name === 'AbortError') return;\n\t\t\t\tthrow e;\n\t\t\t} finally {\n\t\t\t\t// If the user `break`s, abort the ongoing request.\n\t\t\t\tif (!done) controller.abort();\n\t\t\t}\n\t\t}\n\n\t\treturn new Stream(iterator, controller);\n\t}\n\n\t/**\n\t * Generates a Stream from a newline-separated ReadableStream\n\t * where each item is a JSON value.\n\t *\n\t * @template Item - The type of items in the stream.\n\t * @param {ReadableStream} readableStream - The readable stream to create the stream from.\n\t * @param {AbortController} controller - The abort controller to control the stream.\n\t * @returns {Stream<Item>} - The created stream.\n\t */\n\tstatic fromReadableStream<Item>(\n\t\treadableStream: ReadableStream,\n\t\tcontroller: AbortController,\n\t) {\n\t\tlet consumed = false;\n\n\t\tasync function* iterLines(): AsyncGenerator<string, void, unknown> {\n\t\t\tconst lineDecoder = new LineDecoder();\n\n\t\t\tconst iter = readableStreamAsyncIterable<Bytes>(readableStream);\n\t\t\tfor await (const chunk of iter) {\n\t\t\t\tfor (const line of lineDecoder.decode(chunk)) {\n\t\t\t\t\tyield line;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const line of lineDecoder.flush()) {\n\t\t\t\tyield line;\n\t\t\t}\n\t\t}\n\n\t\tasync function* iterator(): AsyncIterator<Item, any, undefined> {\n\t\t\tif (consumed) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot iterate over a consumed stream, use `.tee()` to split the stream.',\n\t\t\t\t);\n\t\t\t}\n\t\t\tconsumed = true;\n\t\t\tlet done = false;\n\t\t\ttry {\n\t\t\t\tfor await (const line of iterLines()) {\n\t\t\t\t\tif (done) continue;\n\t\t\t\t\tif (line) yield JSON.parse(line);\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t} catch (e) {\n\t\t\t\t// If the user calls `stream.controller.abort()`, we should exit without throwing.\n\t\t\t\tif (e instanceof Error && e.name === 'AbortError') return;\n\t\t\t\tthrow e;\n\t\t\t} finally {\n\t\t\t\t// If the user `break`s, abort the ongoing request.\n\t\t\t\tif (!done) controller.abort();\n\t\t\t}\n\t\t}\n\n\t\treturn new Stream(iterator, controller);\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<Item> {\n\t\treturn this.iterator();\n\t}\n\n\t/**\n\t * Splits the stream into two streams which can be\n\t * independently read from at different speeds.\n\t */\n\ttee(): [Stream<Item>, Stream<Item>] {\n\t\tconst left: Array<Promise<IteratorResult<Item>>> = [];\n\t\tconst right: Array<Promise<IteratorResult<Item>>> = [];\n\t\tconst iterator = this.iterator();\n\n\t\tconst teeIterator = (\n\t\t\tqueue: Array<Promise<IteratorResult<Item>>>,\n\t\t): AsyncIterator<Item> => {\n\t\t\treturn {\n\t\t\t\tnext: () => {\n\t\t\t\t\tif (queue.length === 0) {\n\t\t\t\t\t\tconst result = iterator.next();\n\t\t\t\t\t\tleft.push(result);\n\t\t\t\t\t\tright.push(result);\n\t\t\t\t\t}\n\t\t\t\t\treturn queue.shift()!;\n\t\t\t\t},\n\t\t\t};\n\t\t};\n\n\t\treturn [\n\t\t\tnew Stream(() => teeIterator(left), this.controller),\n\t\t\tnew Stream(() => teeIterator(right), this.controller),\n\t\t];\n\t}\n\n\t/**\n\t * Converts this stream to a newline-separated ReadableStream of\n\t * JSON stringified values in the stream which can be turned back into a Stream with `Stream.fromReadableStream()`.\n\t */\n\ttoReadableStream(): ReadableStream {\n\t\tconst self = this;\n\t\tlet iter: AsyncIterator<Item>;\n\t\tconst encoder = new TextEncoder();\n\n\t\treturn new ReadableStream({\n\t\t\tasync start() {\n\t\t\t\titer = self[Symbol.asyncIterator]();\n\t\t\t},\n\t\t\tasync pull(ctrl: any) {\n\t\t\t\ttry {\n\t\t\t\t\tconst {value, done} = await iter.next();\n\t\t\t\t\tif (done) return ctrl.close();\n\n\t\t\t\t\tconst bytes = encoder.encode(JSON.stringify(value) + '\\n');\n\n\t\t\t\t\tctrl.enqueue(bytes);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tctrl.error(err);\n\t\t\t\t}\n\t\t\t},\n\t\t\tasync cancel() {\n\t\t\t\tawait iter.return?.();\n\t\t\t},\n\t\t});\n\t}\n}\n\n/**\n * Asynchronously iterates over Server-Sent Event (SSE) messages from a response body.\n *\n * @param response - The response object containing the SSE messages.\n * @param controller - The AbortController used to abort the iteration if needed.\n * @returns An async generator that yields ServerSentEvent objects.\n * @throws Error if the response has no body.\n */\nexport async function* _iterSSEMessages(\n\tresponse: Response,\n\tcontroller: AbortController,\n): AsyncGenerator<ServerSentEvent, void, unknown> {\n\tif (!response.body) {\n\t\tcontroller.abort();\n\t\tthrow new Error(`Attempted to iterate over a response with no body`);\n\t}\n\n\tconst sseDecoder = new SSEDecoder();\n\tconst lineDecoder = new LineDecoder();\n\n\tconst iter = readableStreamAsyncIterable<Bytes>(response.body);\n\tfor await (const sseChunk of iterSSEChunks(iter)) {\n\t\tfor (const line of lineDecoder.decode(sseChunk)) {\n\t\t\tconst sse = sseDecoder.decode(line);\n\t\t\tif (sse) yield sse;\n\t\t}\n\t}\n\n\tfor (const line of lineDecoder.flush()) {\n\t\tconst sse = sseDecoder.decode(line);\n\t\tif (sse) yield sse;\n\t}\n}\n\n/**\n * Asynchronously iterates over SSE (Server-Sent Events) chunks and yields the data as Uint8Array.\n *\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n *\n * @param iterator - The async iterator that provides the SSE chunks.\n * @returns An async generator that yields Uint8Array chunks.\n */\nasync function* iterSSEChunks(\n\titerator: AsyncIterableIterator<Bytes>,\n): AsyncGenerator<Uint8Array> {\n\tlet data = new Uint8Array();\n\n\tfor await (const chunk of iterator) {\n\t\tif (chunk == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst binaryChunk =\n\t\t\tchunk instanceof ArrayBuffer\n\t\t\t\t? new Uint8Array(chunk)\n\t\t\t\t: typeof chunk === 'string'\n\t\t\t\t\t? new TextEncoder().encode(chunk)\n\t\t\t\t\t: chunk;\n\n\t\tlet newData = new Uint8Array(data.length + binaryChunk.length);\n\t\tnewData.set(data);\n\t\tnewData.set(binaryChunk, data.length);\n\t\tdata = newData;\n\n\t\tlet patternIndex;\n\t\twhile ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n\t\t\tyield data.slice(0, patternIndex);\n\t\t\tdata = data.slice(patternIndex);\n\t\t}\n\t}\n\n\tif (data.length > 0) {\n\t\tyield data;\n\t}\n}\n\n/**\n * Finds the index of the first occurrence of a double newline pattern (\\r\\r, \\n\\n, \\r\\n\\r\\n) in the given buffer.\n *\n * @param buffer - The buffer to search for the double newline pattern.\n * @returns The index right after the first occurrence of the double newline pattern, or -1 if not found.\n */\nfunction findDoubleNewlineIndex(buffer: Uint8Array): number {\n\t// This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n\t// and returns the index right after the first occurrence of any pattern,\n\t// or -1 if none of the patterns are found.\n\tconst newline = 0x0a; // \\n\n\tconst carriage = 0x0d; // \\r\n\n\tfor (let i = 0; i < buffer.length - 2; i++) {\n\t\tif (buffer[i] === newline && buffer[i + 1] === newline) {\n\t\t\t// \\n\\n\n\t\t\treturn i + 2;\n\t\t}\n\t\tif (buffer[i] === carriage && buffer[i + 1] === carriage) {\n\t\t\t// \\r\\r\n\t\t\treturn i + 2;\n\t\t}\n\t\tif (\n\t\t\tbuffer[i] === carriage &&\n\t\t\tbuffer[i + 1] === newline &&\n\t\t\ti + 3 < buffer.length &&\n\t\t\tbuffer[i + 2] === carriage &&\n\t\t\tbuffer[i + 3] === newline\n\t\t) {\n\t\t\t// \\r\\n\\r\\n\n\t\t\treturn i + 4;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Represents a Server-Sent Event (SSE) decoder.\n */\nclass SSEDecoder {\n\tprivate data: string[];\n\tprivate event: string | null;\n\tprivate chunks: string[];\n\n\tconstructor() {\n\t\tthis.event = null;\n\t\tthis.data = [];\n\t\tthis.chunks = [];\n\t}\n\n\t/**\n\t * Decodes a line of text and returns a ServerSentEvent object if a complete event is found.\n\t * @param line - The line of text to decode.\n\t * @returns A ServerSentEvent object if a complete event is found, otherwise null.\n\t */\n\tdecode(line: string) {\n\t\tif (line.endsWith('\\r')) {\n\t\t\tline = line.substring(0, line.length - 1);\n\t\t}\n\n\t\tif (!line) {\n\t\t\t// empty line and we didn't previously encounter any messages\n\t\t\tif (!this.event && !this.data.length) return null;\n\n\t\t\tconst sse: ServerSentEvent = {\n\t\t\t\tevent: this.event,\n\t\t\t\tdata: this.data.join('\\n'),\n\t\t\t\traw: this.chunks,\n\t\t\t};\n\n\t\t\tthis.event = null;\n\t\t\tthis.data = [];\n\t\t\tthis.chunks = [];\n\n\t\t\treturn sse;\n\t\t}\n\n\t\tthis.chunks.push(line);\n\n\t\tif (line.startsWith(':')) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet [fieldname, _, value] = partition(line, ':');\n\n\t\tif (value.startsWith(' ')) {\n\t\t\tvalue = value.substring(1);\n\t\t}\n\n\t\tif (fieldname === 'event') {\n\t\t\tthis.event = value;\n\t\t} else if (fieldname === 'data') {\n\t\t\tthis.data.push(value);\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n\t// prettier-ignore\n\tstatic NEWLINE_CHARS = new Set(['\\n', '\\r']);\n\tstatic NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n\n\tbuffer: string[];\n\ttrailingCR: boolean;\n\ttextDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\n\n\tconstructor() {\n\t\tthis.buffer = [];\n\t\tthis.trailingCR = false;\n\t}\n\n\tdecode(chunk: Bytes): string[] {\n\t\tlet text = this.decodeText(chunk);\n\n\t\tif (this.trailingCR) {\n\t\t\ttext = '\\r' + text;\n\t\t\tthis.trailingCR = false;\n\t\t}\n\t\tif (text.endsWith('\\r')) {\n\t\t\tthis.trailingCR = true;\n\t\t\ttext = text.slice(0, -1);\n\t\t}\n\n\t\tif (!text) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst trailingNewline = LineDecoder.NEWLINE_CHARS.has(\n\t\t\ttext[text.length - 1] || '',\n\t\t);\n\t\tlet lines = text.split(LineDecoder.NEWLINE_REGEXP);\n\n\t\t// if there is a trailing new line then the last entry will be an empty\n\t\t// string which we don't care about\n\t\tif (trailingNewline) {\n\t\t\tlines.pop();\n\t\t}\n\n\t\tif (lines.length === 1 && !trailingNewline) {\n\t\t\tthis.buffer.push(lines[0]!);\n\t\t\treturn [];\n\t\t}\n\n\t\tif (this.buffer.length > 0) {\n\t\t\tlines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n\t\t\tthis.buffer = [];\n\t\t}\n\n\t\tif (!trailingNewline) {\n\t\t\tthis.buffer = [lines.pop() || ''];\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\tdecodeText(bytes: Bytes): string {\n\t\tif (bytes == null) return '';\n\t\tif (typeof bytes === 'string') return bytes;\n\n\t\t// Node:\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\tif (bytes instanceof Buffer) {\n\t\t\t\treturn bytes.toString();\n\t\t\t}\n\t\t\tif (bytes instanceof Uint8Array) {\n\t\t\t\treturn Buffer.from(bytes).toString();\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\n\t\t\t);\n\t\t}\n\n\t\t// Browser\n\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\tif (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n\t\t\t\tthis.textDecoder ??= new TextDecoder('utf8');\n\t\t\t\treturn this.textDecoder.decode(bytes);\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Unexpected: received non-Uint8Array/ArrayBuffer (${\n\t\t\t\t\t(bytes as any).constructor.name\n\t\t\t\t}) in a web platform. Please report this error.`,\n\t\t\t);\n\t\t}\n\n\t\tthrow new Error(\n\t\t\t`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\n\t\t);\n\t}\n\n\tflush(): string[] {\n\t\tif (!this.buffer.length && !this.trailingCR) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst lines = [this.buffer.join('')];\n\t\tthis.buffer = [];\n\t\tthis.trailingCR = false;\n\t\treturn lines;\n\t}\n}\n\n/**\n * Decodes an array of chunks into an array of lines.\n *\n * This is an internal helper function that's just used for testing\n *\n * @param chunks - An array of chunks to decode.\n * @returns An array of decoded lines.\n */\nexport function _decodeChunks(chunks: string[]): string[] {\n\tconst decoder = new LineDecoder();\n\tconst lines: string[] = [];\n\tfor (const chunk of chunks) {\n\t\tlines.push(...decoder.decode(chunk));\n\t}\n\n\treturn lines;\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n\tconst index = str.indexOf(delimiter);\n\tif (index !== -1) {\n\t\treturn [\n\t\t\tstr.substring(0, index),\n\t\t\tdelimiter,\n\t\t\tstr.substring(index + delimiter.length),\n\t\t];\n\t}\n\n\treturn [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function readableStreamAsyncIterable<T>(\n\tstream: any,\n): AsyncIterableIterator<T> {\n\tif (stream[Symbol.asyncIterator]) return stream;\n\n\tconst reader = stream.getReader();\n\treturn {\n\t\tasync next() {\n\t\t\ttry {\n\t\t\t\tconst result = await reader.read();\n\t\t\t\tif (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\treader.releaseLock(); // release lock when stream becomes errored\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t},\n\t\tasync return() {\n\t\t\tconst cancelPromise = reader.cancel();\n\t\t\treader.releaseLock();\n\t\t\tawait cancelPromise;\n\t\t\treturn {done: true, value: undefined};\n\t\t},\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t};\n}\n","import {GENERATION_ENDPOINTS} from '@/data/constants';\nimport {Headers} from './../../types'; // Ensure this import is correct\nimport {APIConnectionError, APIError} from './errors';\nimport {Stream} from './stream';\n\ninterface RequestOptions {\n\tendpoint: string;\n\tmethod: string;\n\theaders?: Headers;\n\tbody?: any;\n\tstream?: boolean;\n}\n\ninterface RequestConfig {\n\tapiKey: string;\n\tbaseUrl: string;\n\ttimeout?: number;\n}\n\ninterface SendOptions extends RequestOptions {\n\tendpoint: string;\n}\n\ninterface MakeRequestParams {\n\turl: string;\n\toptions: RequestOptions;\n\theaders: Record<string, string>;\n}\n\ninterface HandleGenerateResponseParams {\n\tresponse: Response;\n\tthreadId: string | null;\n\trawResponse: boolean;\n\tendpoint?: string;\n}\n\nexport class Request {\n\tprivate config: RequestConfig;\n\n\tconstructor(config: RequestConfig) {\n\t\tthis.config = config;\n\t}\n\n\t// Main send function\n\tprivate async send<T>({endpoint, ...options}: SendOptions): Promise<T> {\n\t\tconst url = this.buildUrl({endpoint});\n\t\tconst headers = this.buildHeaders({headers: options.headers});\n\n\t\tlet response: Response;\n\t\ttry {\n\t\t\tresponse = await this.makeRequest({url, options, headers});\n\t\t} catch (error) {\n\t\t\tthrow new APIConnectionError({\n\t\t\t\tcause: error instanceof Error ? error : undefined,\n\t\t\t});\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tawait this.handleErrorResponse({response});\n\t\t}\n\n\t\tconst isLllmGenerationEndpoint =\n\t\t\tGENERATION_ENDPOINTS.includes(endpoint);\n\n\t\t// All endpoints should return headers if rawResponse is true\n\t\tif (!isLllmGenerationEndpoint && options.body?.rawResponse) {\n\t\t\tconst responseData = await response.json();\n\t\t\treturn {\n\t\t\t\t...responseData,\n\t\t\t\trawResponse: {\n\t\t\t\t\theaders: Object.fromEntries(response.headers.entries()),\n\t\t\t\t},\n\t\t\t} as T;\n\t\t}\n\n\t\tif (isLllmGenerationEndpoint) {\n\t\t\tconst threadId = response.headers.get('lb-thread-id');\n\n\t\t\tif (!options.body) {\n\t\t\t\treturn this.handleRunResponse({\n\t\t\t\t\tresponse,\n\t\t\t\t\tthreadId: null,\n\t\t\t\t\trawResponse: options.body?.rawResponse ?? false,\n\t\t\t\t\tendpoint,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (options.body?.stream && url.includes('run')) {\n\t\t\t\treturn this.handleRunResponseStream({\n\t\t\t\t\tresponse,\n\t\t\t\t\trawResponse: options.body.rawResponse,\n\t\t\t\t}) as T;\n\t\t\t}\n\n\t\t\tif (options.body.stream) {\n\t\t\t\treturn this.handleStreamResponse({response}) as T;\n\t\t\t}\n\n\t\t\treturn this.handleRunResponse({\n\t\t\t\tresponse,\n\t\t\t\tthreadId,\n\t\t\t\trawResponse: options.body?.rawResponse ?? false,\n\t\t\t\tendpoint,\n\t\t\t});\n\t\t} else {\n\t\t\tconst res = response.json();\n\t\t\treturn res as T;\n\t\t}\n\t}\n\n\tprivate buildUrl({endpoint}: {endpoint: string}): string {\n\t\treturn `${this.config.baseUrl}${endpoint}`;\n\t}\n\n\tprivate buildHeaders({\n\t\theaders,\n\t}: {\n\t\theaders?: Record<string, string>;\n\t}): Record<string, string> {\n\t\treturn {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${this.config.apiKey}`,\n\t\t\t...headers,\n\t\t};\n\t}\n\n\tprivate async makeRequest({\n\t\turl,\n\t\toptions,\n\t\theaders,\n\t}: MakeRequestParams): Promise<Response> {\n\t\treturn fetch(url, {\n\t\t\tmethod: options.method,\n\t\t\theaders,\n\t\t\tbody: JSON.stringify(options.body),\n\t\t\t// signal: AbortSignal.timeout(this.config.timeout || 30000),\n\t\t});\n\t}\n\n\tprivate async handleErrorResponse({\n\t\tresponse,\n\t}: {\n\t\tresponse: Response;\n\t}): Promise<never> {\n\t\tlet errorBody;\n\t\ttry {\n\t\t\terrorBody = await response.json();\n\t\t} catch {\n\t\t\terrorBody = await response.text();\n\t\t}\n\t\tthrow APIError.generate(\n\t\t\tresponse.status,\n\t\t\terrorBody,\n\t\t\tresponse.statusText,\n\t\t\tresponse.headers as unknown as Headers,\n\t\t);\n\t}\n\n\tprivate handleStreamResponse({response}: {response: Response}): {\n\t\tstream: any;\n\t\tthreadId: string | null;\n\t} {\n\t\tconst controller = new AbortController();\n\t\tconst stream = Stream.fromSSEResponse(response, controller);\n\t\treturn {stream, threadId: response.headers.get('lb-thread-id')};\n\t}\n\n\tprivate handleRunResponseStream({\n\t\tresponse,\n\t\trawResponse,\n\t}: {\n\t\tresponse: Response;\n\t\trawResponse?: boolean;\n\t}): {\n\t\tstream: any;\n\t\tthreadId: string | null;\n\t\trawResponse?: {\n\t\t\theaders: Record<string, string>;\n\t\t};\n\t} {\n\t\tconst controller = new AbortController();\n\t\tconst streamSSE = Stream.fromSSEResponse(response, controller);\n\t\tconst stream = streamSSE.toReadableStream();\n\n\t\tconst result: {\n\t\t\tstream: ReadableStream<any>;\n\t\t\tthreadId: string | null;\n\t\t\trawResponse?: {\n\t\t\t\theaders: Record<string, string>;\n\t\t\t};\n\t\t} = {\n\t\t\tstream,\n\t\t\tthreadId: response.headers.get('lb-thread-id'),\n\t\t};\n\t\tif (rawResponse) {\n\t\t\tresult.rawResponse = {\n\t\t\t\theaders: Object.fromEntries(response.headers.entries()),\n\t\t\t};\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate async handleRunResponse({\n\t\tresponse,\n\t\tthreadId,\n\t\trawResponse,\n\t\tendpoint,\n\t}: HandleGenerateResponseParams): Promise<any> {\n\t\tlet isAgentRun = false;\n\t\tif (endpoint === '/v1/agent/run') isAgentRun = true;\n\n\t\tconst generateResponse = await response.json();\n\n\t\tconst buildResponse = generateResponse.raw\n\t\t\t? isAgentRun\n\t\t\t\t? {\n\t\t\t\t\t\toutput: generateResponse.output,\n\t\t\t\t\t\t...generateResponse.raw,\n\t\t\t\t\t}\n\t\t\t\t: {\n\t\t\t\t\t\tcompletion: generateResponse.completion,\n\t\t\t\t\t\t...generateResponse.raw,\n\t\t\t\t\t}\n\t\t\t: generateResponse;\n\n\t\tconst result: any = {\n\t\t\t...buildResponse,\n\t\t};\n\n\t\tif (threadId) {\n\t\t\tresult.threadId = threadId;\n\t\t}\n\n\t\tif (rawResponse) {\n\t\t\tresult.rawResponse = {\n\t\t\t\theaders: Object.fromEntries(response.headers.entries()),\n\t\t\t};\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tasync post<T>(options: Omit<RequestOptions, 'method'>): Promise<T> {\n\t\treturn this.send<T>({...options, method: 'POST'});\n\t}\n\n\tasync get<T>(options: Omit<RequestOptions, 'method' | 'body'>): Promise<T> {\n\t\treturn this.send<T>({...options, method: 'GET'});\n\t}\n\n\tasync put<T>(options: Omit<RequestOptions, 'method'>): Promise<T> {\n\t\treturn this.send<T>({...options, method: 'PUT'});\n\t}\n\n\tasync delete<T>(\n\t\toptions: Omit<RequestOptions, 'method' | 'body'>,\n\t): Promise<T> {\n\t\treturn this.send<T>({...options, method: 'DELETE'});\n\t}\n}\n","export interface Trace {\n\tname: string;\n\tstartTime: number;\n\tendTime?: number;\n\tduration?: number;\n\tsteps: StepTrace[];\n\terror?: string;\n}\n\nexport interface StepTrace {\n\tname: string;\n\toutput: any;\n\terror?: string;\n\ttraces: string[] | null;\n\tduration: number;\n\tstartTime: number;\n\tendTime: number;\n}\n\nexport type TraceType =\n\t| 'workflow'\n\t| 'agent'\n\t| 'chunk'\n\t| 'memory'\n\t| 'parse'\n\t| 'embed';\n\nexport type PrimitiveTrace =\n\t| {chunk: any}\n\t| {agent: any}\n\t| {memory: any}\n\t| {parse: any}\n\t| {embed: any}\n\t| {workflow: WorkflowTrace; entityAuthId: string};\n\ntype WorkflowTrace = {\n\tcreatedAt: string;\n\tid: string;\n\tagentWorkflowId: string;\n\tname: string;\n\tstartTime: number;\n\tendTime?: number;\n\tduration?: number;\n\tsteps: StepTrace[];\n\terror?: string;\n};\n\nexport class TraceManager {\n\tprivate traces: Map<string, PrimitiveTrace> = new Map();\n\n\tcreateTrace(type: TraceType, traceData: any = {}): string {\n\t\tconst traceId = crypto.randomUUID();\n\t\tlet trace: PrimitiveTrace;\n\t\tconst createdAt = new Date().toISOString();\n\t\tconst agentWorkflowId =\n\t\t\ttypeof process !== 'undefined' && process.env?.LANGBASE_AGENT_ID\n\t\t\t\t? process.env.LANGBASE_AGENT_ID\n\t\t\t\t: '';\n\n\t\tif (type === 'workflow') {\n\t\t\ttrace = {\n\t\t\t\tworkflow: {\n\t\t\t\t\tcreatedAt,\n\t\t\t\t\tid: traceId,\n\t\t\t\t\tagentWorkflowId,\n\t\t\t\t\tname: traceData.name || '',\n\t\t\t\t\tstartTime: Date.now(),\n\t\t\t\t\tsteps: [],\n\t\t\t\t},\n\t\t\t\tentityAuthId: '',\n\t\t\t};\n\t\t} else if (type === 'agent') {\n\t\t\ttrace = {agent: {...traceData, createdAt, id: traceId}};\n\t\t} else if (type === 'chunk') {\n\t\t\ttrace = {chunk: {...traceData, createdAt, id: traceId}};\n\t\t} else if (type === 'memory') {\n\t\t\ttrace = {memory: {...traceData, createdAt, id: traceId}};\n\t\t} else if (type === 'parse') {\n\t\t\ttrace = {parse: {...traceData, createdAt, id: traceId}};\n\t\t} else if (type === 'embed') {\n\t\t\ttrace = {embed: {...traceData, createdAt, id: traceId}};\n\t\t} else {\n\t\t\tthrow new Error('Unknown trace type');\n\t\t}\n\t\tthis.traces.set(traceId, trace);\n\t\treturn traceId;\n\t}\n\n\taddStep(traceId: string, step: StepTrace) {\n\t\tconst trace = this.traces.get(traceId);\n\t\tif (trace && 'workflow' in trace) {\n\t\t\ttrace.workflow.steps.push(step);\n\t\t}\n\t}\n\n\tendTrace(traceId: string) {\n\t\tconst trace = this.traces.get(traceId);\n\t\tif (trace && 'workflow' in trace) {\n\t\t\ttrace.workflow.endTime = Date.now();\n\t\t\ttrace.workflow.duration =\n\t\t\t\ttrace.workflow.endTime - trace.workflow.startTime;\n\t\t}\n\t}\n\n\tgetTrace(traceId: string): PrimitiveTrace | undefined {\n\t\treturn this.traces.get(traceId);\n\t}\n\n\tprintTrace(traceId: string) {\n\t\tconst trace = this.traces.get(traceId);\n\t\tif (!trace) return;\n\t\tif ('workflow' in trace) {\n\t\t\tconst wf = trace.workflow;\n\t\t\tconst duration = wf.endTime\n\t\t\t\t? wf.endTime - wf.startTime\n\t\t\t\t: Date.now() - wf.startTime;\n\t\t\tconsole.log('\\nüìä Workflow Trace:');\n\t\t\tconsole.log(`Name: ${wf.name}`);\n\t\t\tconsole.log(`Duration: ${duration}ms`);\n\t\t\tconsole.log(`Start Time: ${new Date(wf.startTime).toISOString()}`);\n\t\t\tif (wf.endTime) {\n\t\t\t\tconsole.log(`End Time: ${new Date(wf.endTime).toISOString()}`);\n\t\t\t}\n\t\t\tconsole.log('\\nSteps:');\n\t\t\twf.steps.forEach(step => {\n\t\t\t\tconsole.log(`\\n  Step: ${step.name}`);\n\t\t\t\tconsole.log(`  Duration: ${step.duration}ms`);\n\t\t\t\tif (step.traces && step.traces.length > 0) {\n\t\t\t\t\tconsole.log(`  Traces:`, step.traces);\n\t\t\t\t}\n\t\t\t\tconsole.log(`  Output:`, step.output);\n\t\t\t});\n\t\t} else {\n\t\t\tconsole.log('\\nüìä Primitive Trace:');\n\t\t\tconsole.dir(trace, {depth: 4});\n\t\t}\n\t}\n}\n","import {TraceManager, StepTrace} from './trace';\nimport {Langbase} from './langbase';\n\n// Cross-platform global object\nconst _global: any =\n\ttypeof global !== 'undefined'\n\t\t? global\n\t\t: typeof window !== 'undefined'\n\t\t\t? window\n\t\t\t: typeof self !== 'undefined'\n\t\t\t\t? self\n\t\t\t\t: typeof globalThis !== 'undefined'\n\t\t\t\t\t? globalThis\n\t\t\t\t\t: {};\n\n// Global state for tracing\n_global._activeTraceCollector = _global._activeTraceCollector || null;\n_global._workflowDebugEnabled = _global._workflowDebugEnabled || false;\n\ntype WorkflowContext = {\n\toutputs: Record<string, any>;\n};\n\ntype RetryConfig = {\n\tlimit: number;\n\tdelay: number;\n\tbackoff: 'exponential' | 'linear' | 'fixed';\n};\n\ntype StepConfig<T = any> = {\n\tid: string;\n\ttimeout?: number;\n\tretries?: RetryConfig;\n\trun: () => Promise<T>;\n};\n\ntype WorkflowConfig = {\n\tdebug?: boolean;\n\tname?: string;\n\tlangbase?: Langbase; // Now optional for backward compatibility\n};\n\nclass TimeoutError extends Error {\n\tconstructor(stepId: string, timeout: number) {\n\t\tsuper(`Step \"${stepId}\" timed out after ${timeout}ms`);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\nexport class Workflow {\n\tprivate context: WorkflowContext;\n\tprivate debug: boolean;\n\tprivate name: string;\n\tprivate traceManager?: TraceManager; // Optional\n\tprivate traceId?: string; // Optional\n\tprivate langbase?: Langbase; // Optional\n\n\tprivate originalMethods: Map<string, Function> = new Map();\n\tpublic readonly step: <T = any>(config: StepConfig<T>) => Promise<T>;\n\n\tconstructor(config: WorkflowConfig) {\n\t\tthis.context = {outputs: {}};\n\t\tthis.debug = config.debug ?? false;\n\t\tthis.name = config.name ?? 'workflow';\n\t\tthis.langbase = config.langbase;\n\n\t\t// Only initialize tracing if langbase is provided\n\t\tif (this.langbase) {\n\t\t\tthis.traceManager = new TraceManager();\n\t\t\tthis.traceId = this.traceManager.createTrace('workflow', {\n\t\t\t\tname: this.name,\n\t\t\t});\n\t\t\t// Set global debug flag\n\t\t\t_global._workflowDebugEnabled = this.debug;\n\t\t}\n\t\tthis.step = this._step.bind(this);\n\t}\n\n\t/**\n\t * Replace a method in the Langbase instance with a traced version\n\t */\n\tprivate interceptMethod(obj: any, method: string, path: string = ''): void {\n\t\tif (!this.langbase) return; // Skip if no langbase instance provided (no tracing)\n\t\tif (!obj || typeof obj[method] !== 'function') return;\n\n\t\tconst fullPath = path ? `${path}.${method}` : method;\n\t\tconst originalMethod = obj[method];\n\n\t\t// Only replace if not already intercepted\n\t\tif (!this.originalMethods.has(fullPath)) {\n\t\t\tthis.originalMethods.set(fullPath, originalMethod);\n\n\t\t\tconst debug = this.debug;\n\n\t\t\t// Replace with intercepted version\n\t\t\tobj[method] = async function (...args: any[]) {\n\t\t\t\t// Add custom arguments for tracing\n\t\t\t\t// Add rawResponse to the options if it's an object\n\t\t\t\tconst lastArg = args[args.length - 1];\n\t\t\t\tconst newArgs = [...args];\n\n\t\t\t\tif (lastArg && typeof lastArg === 'object') {\n\t\t\t\t\tnewArgs[newArgs.length - 1] = {\n\t\t\t\t\t\t...lastArg,\n\t\t\t\t\t\trawResponse: true,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Append a new object if the last argument is not an object\n\t\t\t\telse {\n\t\t\t\t\tnewArgs.push({rawResponse: true});\n\t\t\t\t}\n\n\t\t\t\tconst result = await originalMethod.apply(this, newArgs);\n\t\t\t\tconsole.log(`üîÑ Intercepted method: ${fullPath}`, result);\n\n\t\t\t\t// Process result for tracing if we have an active collector\n\t\t\t\tif (_global._activeTraceCollector) {\n\t\t\t\t\t// Extract or create traceId\n\t\t\t\t\tlet traceId: string | undefined;\n\n\t\t\t\t\t// Check if result is an object with response headers\n\t\t\t\t\tif (result && typeof result === 'object') {\n\t\t\t\t\t\t// Extract from response headers\n\t\t\t\t\t\tif ('rawResponse' in result && result.rawResponse) {\n\t\t\t\t\t\t\t// Check for lb-trace-id in headers\n\t\t\t\t\t\t\tif (result.rawResponse.headers['lb-trace-id']) {\n\t\t\t\t\t\t\t\t// Plain object headers\n\t\t\t\t\t\t\t\ttraceId =\n\t\t\t\t\t\t\t\t\tresult.rawResponse.headers['lb-trace-id'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Notify collector if traceId was found\n\t\t\t\t\t\tif (traceId && _global._activeTraceCollector) {\n\t\t\t\t\t\t\tif (debug)\n\t\t\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t\t\t`üîç Trace ID extracted: ${traceId}`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t_global._activeTraceCollector(traceId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Restore all original methods that were intercepted\n\t */\n\tprivate restoreOriginalMethods(): void {\n\t\tif (!this.langbase) return; // Skip if no langbase (no tracing)\n\t\tthis.originalMethods.forEach((originalMethod, path) => {\n\t\t\t// Parse the path to find the object and method\n\t\t\tconst parts = path.split('.');\n\t\t\tconst methodName = parts.pop()!;\n\t\t\tlet obj: any = this.langbase;\n\n\t\t\t// Navigate to the correct object\n\t\t\tfor (const part of parts) {\n\t\t\t\tif (obj && typeof obj === 'object' && part in obj) {\n\t\t\t\t\tobj = obj[part as keyof typeof obj]; // Type safe access\n\t\t\t\t} else {\n\t\t\t\t\treturn; // Skip if path no longer exists\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Restore original method\n\t\t\tif (\n\t\t\t\tobj &&\n\t\t\t\tmethodName in obj &&\n\t\t\t\ttypeof obj[methodName] === 'function'\n\t\t\t) {\n\t\t\t\tobj[methodName] = originalMethod;\n\t\t\t}\n\t\t});\n\n\t\t// Clear the map\n\t\tthis.originalMethods.clear();\n\t}\n\n\t/**\n\t * Intercept all important methods in the Langbase instance\n\t */\n\tprivate setupMethodInterceptors(): void {\n\t\tif (!this.langbase) return; // Skip if no langbase (no tracing)\n\t\t// Agent methods\n\t\tthis.interceptMethod(this.langbase.agent, 'run', 'agent');\n\n\t\t// Pipes methods\n\t\tthis.interceptMethod(this.langbase.pipes, 'run', 'pipes');\n\t\tthis.interceptMethod(this.langbase.pipe, 'run', 'pipe');\n\n\t\t// Memory methods\n\t\tif (this.langbase.memories) {\n\t\t\tthis.interceptMethod(\n\t\t\t\tthis.langbase.memories,\n\t\t\t\t'retrieve',\n\t\t\t\t'memories',\n\t\t\t);\n\t\t}\n\t\tif (this.langbase.memory) {\n\t\t\tthis.interceptMethod(this.langbase.memory, 'retrieve', 'memory');\n\t\t}\n\n\t\t// Tool methods\n\t\tif (this.langbase.tools) {\n\t\t\tthis.interceptMethod(this.langbase.tools, 'webSearch', 'tools');\n\t\t\tthis.interceptMethod(this.langbase.tools, 'crawl', 'tools');\n\t\t}\n\t\tif (this.langbase.tool) {\n\t\t\tthis.interceptMethod(this.langbase.tool, 'webSearch', 'tool');\n\t\t\tthis.interceptMethod(this.langbase.tool, 'crawl', 'tool');\n\t\t}\n\n\t\t// Top-level methods\n\t\tthis.interceptMethod(this.langbase, 'embed');\n\t\tthis.interceptMethod(this.langbase, 'chunk');\n\t\tthis.interceptMethod(this.langbase, 'parse');\n\t}\n\n\tprivate async _step<T = any>(config: StepConfig<T>): Promise<T> {\n\t\tconst stepStartTime = Date.now();\n\t\t// Initialize an array to collect trace IDs\n\t\tconst stepTraces: string[] = [];\n\n\t\t// Function to collect trace IDs\n\t\tconst collectTrace = (traceId: string) => {\n\t\t\tif (this.debug) {\n\t\t\t\tconsole.log(`üìã Collected trace ID: ${traceId}`);\n\t\t\t}\n\t\t\tstepTraces.push(traceId);\n\t\t};\n\n\t\tif (this.debug) {\n\t\t\tconsole.log(`\\nüîÑ Starting step: ${config.id}`);\n\t\t\tconsole.time(`‚è±Ô∏è Step ${config.id}`);\n\t\t\tif (config.timeout) console.log(`‚è≥ Timeout: ${config.timeout}ms`);\n\t\t\tif (config.retries)\n\t\t\t\tconsole.log(`üîÑ Retries: ${JSON.stringify(config.retries)}`);\n\t\t}\n\n\t\tlet lastError: Error | null = null;\n\t\tlet attempt = 1;\n\t\tconst maxAttempts = config.retries?.limit\n\t\t\t? config.retries.limit + 1\n\t\t\t: 1;\n\n\t\t// Set up method interceptors before running the step (only if tracing)\n\t\tif (this.langbase) this.setupMethodInterceptors();\n\n\t\t// Set the global active trace collector (only if tracing)\n\t\tconst previousTraceCollector = _global._activeTraceCollector;\n\t\tif (this.langbase) _global._activeTraceCollector = collectTrace;\n\n\t\ttry {\n\t\t\t// Execute the step function directly\n\t\t\tlet stepPromise: Promise<T> = config.run();\n\n\t\t\t// Apply timeout if configured\n\t\t\tif (config.timeout) {\n\t\t\t\tstepPromise = this.withTimeout({\n\t\t\t\t\tpromise: stepPromise,\n\t\t\t\t\ttimeout: config.timeout,\n\t\t\t\t\tstepId: config.id,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Wait for the step to complete\n\t\t\tconst result = await stepPromise;\n\n\t\t\t// Store step result in context\n\t\t\tthis.context.outputs[config.id] = result;\n\n\t\t\tif (this.debug) {\n\t\t\t\tconsole.timeEnd(`‚è±Ô∏è Step ${config.id}`);\n\t\t\t\tconsole.log(`üì§ Output:`, result);\n\n\t\t\t\tif (stepTraces.length > 0) {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`üìã Trace IDs (${stepTraces.length}):`,\n\t\t\t\t\t\tstepTraces,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(`üîç No trace IDs captured for this step`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create step trace (only if tracing)\n\t\t\tif (this.langbase && this.traceManager && this.traceId) {\n\t\t\t\tconst stepEndTime = Date.now();\n\t\t\t\tconst stepTrace: StepTrace = {\n\t\t\t\t\tname: config.id,\n\t\t\t\t\toutput: result,\n\t\t\t\t\ttraces: stepTraces.length > 0 ? stepTraces : null,\n\t\t\t\t\tduration: stepEndTime - stepStartTime,\n\t\t\t\t\tstartTime: stepStartTime,\n\t\t\t\t\tendTime: stepEndTime,\n\t\t\t\t};\n\t\t\t\tthis.traceManager.addStep(this.traceId, stepTrace);\n\t\t\t}\n\n\t\t\t// Restore original methods and trace collector (only if tracing)\n\t\t\tif (this.langbase) {\n\t\t\t\tthis.restoreOriginalMethods();\n\t\t\t\t_global._activeTraceCollector = previousTraceCollector;\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\t// Restore original methods and trace collector on error (only if tracing)\n\t\t\tif (this.langbase) {\n\t\t\t\tthis.restoreOriginalMethods();\n\t\t\t\t_global._activeTraceCollector = previousTraceCollector;\n\t\t\t}\n\n\t\t\t// Store error for potential retry or final throw\n\t\t\tlastError = error as Error;\n\n\t\t\t// If retries are configured, try again\n\t\t\tif (attempt < maxAttempts) {\n\t\t\t\tconst delay = config.retries\n\t\t\t\t\t? this.calculateDelay(\n\t\t\t\t\t\t\tconfig.retries.delay,\n\t\t\t\t\t\t\tattempt,\n\t\t\t\t\t\t\tconfig.retries.backoff,\n\t\t\t\t\t\t)\n\t\t\t\t\t: 0;\n\n\t\t\t\tif (this.debug) {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`‚ö†Ô∏è Attempt ${attempt} failed, retrying in ${delay}ms...`,\n\t\t\t\t\t);\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t}\n\n\t\t\t\tawait this.sleep(delay);\n\t\t\t\tattempt++;\n\n\t\t\t\t// Try again with the next attempt\n\t\t\t\treturn this._step(config);\n\t\t\t} else {\n\t\t\t\tif (this.debug) {\n\t\t\t\t\tconsole.timeEnd(`‚è±Ô∏è Step ${config.id}`);\n\t\t\t\t\tconsole.error(`‚ùå Failed step: ${config.id}`, error);\n\t\t\t\t}\n\t\t\t\tthrow lastError;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async withTimeout<T>({\n\t\tpromise,\n\t\ttimeout,\n\t\tstepId,\n\t}: {\n\t\tpromise: Promise<T>;\n\t\ttimeout: number;\n\t\tstepId: string;\n\t}): Promise<T> {\n\t\tconst timeoutPromise = new Promise<never>((_, reject) => {\n\t\t\tsetTimeout(\n\t\t\t\t() => reject(new TimeoutError(stepId, timeout)),\n\t\t\t\ttimeout,\n\t\t\t);\n\t\t});\n\t\treturn Promise.race([promise, timeoutPromise]);\n\t}\n\n\tprivate calculateDelay(\n\t\tbaseDelay: number,\n\t\tattempt: number,\n\t\tbackoff: RetryConfig['backoff'],\n\t): number {\n\t\tswitch (backoff) {\n\t\t\tcase 'exponential':\n\t\t\t\treturn baseDelay * Math.pow(2, attempt - 1);\n\t\t\tcase 'linear':\n\t\t\t\treturn baseDelay * attempt;\n\t\t\tcase 'fixed':\n\t\t\tdefault:\n\t\t\t\treturn baseDelay;\n\t\t}\n\t}\n\n\tprivate async sleep(ms: number): Promise<void> {\n\t\treturn new Promise(resolve => setTimeout(resolve, ms));\n\t}\n\n\tpublic async end(): Promise<void> {\n\t\t// If tracing is not enabled, do nothing (no-op for backward compatibility)\n\t\tif (!this.langbase || !this.traceManager || !this.traceId) return;\n\t\t// Finalise and grab the trace\n\t\tthis.traceManager.endTrace(this.traceId);\n\t\tthis.traceManager.printTrace(this.traceId);\n\t\tconst traceData = this.traceManager.getTrace(this.traceId);\n\n\t\t// --- send to LB API v1/traces/create using SDK method ---\n\t\ttry {\n\t\t\tconst res = await this.langbase.traces.create(traceData);\n\n\t\t\tif (!res || res.error) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`‚ùå Trace upload failed: ${res?.status || ''} ${res?.statusText || ''}`,\n\t\t\t\t);\n\t\t\t} else if (this.debug) {\n\t\t\t\tconsole.log(`‚úÖ Trace ${this.traceId} sent to collector`);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error('‚ùå Error while sending trace', err);\n\t\t}\n\t\t// -------------------------------------------------------------------------\n\n\t\tif (this.debug) {\n\t\t\tconsole.log('\\nüîç DEBUG: Final trace data:');\n\t\t\tconsole.log(JSON.stringify(traceData, null, 2));\n\t\t}\n\t}\n}\n","import {convertDocToFormData} from '@/lib/utils/doc-to-formdata';\nimport {Request} from '../common/request';\nimport {Workflow} from './workflows';\n\nexport type Role = 'user' | 'assistant' | 'system' | 'tool';\n\nexport interface RunOptionsBase {\n\tmessages?: Message[];\n\tvariables?: Variable[];\n\tthreadId?: string;\n\trawResponse?: boolean;\n\trunTools?: boolean;\n\ttools?: Tools[];\n\tname?: string; // Pipe name for SDK,\n\tapiKey?: string; // pipe level key for SDK\n\tllmKey?: string; // LLM API key\n\tjson?: boolean;\n\tmemory?: RuntimeMemory;\n}\n\nexport interface RunOptionsT extends RunOptionsBase {\n\tstream?: false;\n}\n\nexport interface RunOptionsStreamT extends RunOptionsBase {\n\tstream: true;\n}\n\nexport interface AgentRunOptionsBase {\n\tinput: string | PromptMessage[];\n\tinstructions?: string | null;\n\tmodel: string;\n\tapiKey: string;\n\ttop_p?: number;\n\tmax_tokens?: number;\n\ttemperature?: number;\n\tpresence_penalty?: number;\n\tfrequency_penalty?: number;\n\tstop?: string[];\n\ttools?: Tools[];\n\ttool_choice?: 'auto' | 'required' | ToolChoice;\n\tparallel_tool_calls?: boolean;\n\tmcp_servers?: McpServerSchema[];\n\treasoning_effort?: string | null;\n\tmax_completion_tokens?: number;\n\tresponse_format?: ResponseFormat;\n\tcustomModelParams?: Record<string, any>;\n}\n\nexport type AgentRunOptionsWithoutMcp = Omit<\n\tAgentRunOptionsBase,\n\t'mcp_servers'\n> & {\n\tstream?: false;\n};\n\nexport type AgentRunOptionsWithMcp = AgentRunOptionsBase & {\n\tmcp_servers: McpServerSchema[];\n\tstream: false;\n};\n\nexport type AgentRunOptionsStreamT = Omit<\n\tAgentRunOptionsBase,\n\t'mcp_servers'\n> & {\n\tstream: true;\n};\n\nexport type AgentRunOptions =\n\t| AgentRunOptionsWithoutMcp\n\t| AgentRunOptionsWithMcp;\nexport type AgentRunOptionsStream = AgentRunOptionsStreamT;\n\nexport interface McpServerSchema {\n\tname: string;\n\ttype: 'url';\n\turl: string;\n\tauthorization_token?: string;\n\ttool_configuration?: {\n\t\tallowed_tools?: string[];\n\t\tenabled?: boolean;\n\t};\n\tcustom_headers?: Record<string, string>;\n}\n\ninterface ChoiceGenerate {\n\tindex: number;\n\tmessage: Message;\n\tlogprobs: boolean | null;\n\tfinish_reason: string;\n}\n\nexport interface Usage {\n\tprompt_tokens: number;\n\tcompletion_tokens: number;\n\ttotal_tokens: number;\n}\n\nexport interface RunResponse {\n\tcompletion: string;\n\tthreadId?: string;\n\tid: string;\n\tobject: string;\n\tcreated: number;\n\tmodel: string;\n\tchoices: ChoiceGenerate[];\n\tusage: Usage;\n\tsystem_fingerprint: string | null;\n\trawResponse?: {\n\t\theaders: Record<string, string>;\n\t};\n}\n\nexport interface AgentRunResponse {\n\toutput: string;\n\tthreadId?: string;\n\tid: string;\n\tobject: string;\n\tcreated: number;\n\tmodel: string;\n\tchoices: ChoiceGenerate[];\n\tusage: Usage;\n\tsystem_fingerprint: string | null;\n\trawResponse?: {\n\t\theaders: Record<string, string>;\n\t};\n}\n\nexport interface RunResponseStream {\n\tstream: ReadableStream<any>;\n\tthreadId: string | null;\n\trawResponse?: {\n\t\theaders: Record<string, string>;\n\t};\n}\n\n// Union type for RunOptions\nexport type RunOptions =\n\t| (RunOptionsT & {name: string; apiKey?: never})\n\t| (RunOptionsT & {name?: never; apiKey: string});\n\nexport type RunOptionsStream =\n\t| (RunOptionsStreamT & {name: string; apiKey?: never})\n\t| (RunOptionsStreamT & {name?: never; apiKey: string});\n\nexport interface Function {\n\tname: string;\n\targuments: string;\n}\n\nexport type RuntimeMemory = {\n\tname: string;\n}[];\n\nexport interface ToolCall {\n\tid: string;\n\ttype: 'function';\n\tfunction: Function;\n}\n\nexport interface Message {\n\trole: Role;\n\tcontent: string | null;\n\tname?: string;\n\ttool_call_id?: string;\n\ttool_calls?: ToolCall[];\n}\n\n// Message with proper content type for Vision support\nexport interface PromptMessage {\n\trole: Role;\n\tcontent: string | MessageContentType[] | null;\n\tname?: string;\n\ttool_call_id?: string;\n\ttool_calls?: ToolCall[];\n}\n\nexport interface MessageContentType {\n\ttype: string;\n\ttext?: string;\n\timage_url?: {\n\t\turl: string;\n\t\tdetail?: string;\n\t};\n\tcache_control?: {\n\t\ttype: 'ephemeral';\n\t};\n}\n\nexport type ResponseFormat =\n\t| {type: 'text'}\n\t| {type: 'json_object'}\n\t| {\n\t\t\ttype: 'json_schema';\n\t\t\tjson_schema: {\n\t\t\t\tdescription?: string;\n\t\t\t\tname: string;\n\t\t\t\tschema?: Record<string, unknown>;\n\t\t\t\tstrict?: boolean | null;\n\t\t\t};\n\t  };\n\nexport interface ThreadMessage extends Message {\n\tattachments?: any[];\n\tmetadata?: Record<string, string>;\n}\n\nexport interface Variable {\n\tname: string;\n\tvalue: string;\n}\n\ninterface ToolChoice {\n\ttype: 'function';\n\tfunction: {name: string};\n}\n\nexport interface Tools {\n\ttype: 'function';\n\tfunction: {\n\t\tname: string;\n\t\tdescription?: string;\n\t\tparameters?: Record<string, any>;\n\t};\n}\n\ninterface PipeBaseOptions {\n\tname: string;\n\tdescription?: string;\n\tstatus?: 'public' | 'private';\n\tupsert?: boolean;\n\tmodel?: string;\n\tstream?: boolean;\n\tjson?: boolean;\n\tstore?: boolean;\n\tmoderate?: boolean;\n\ttop_p?: number;\n\tmax_tokens?: number;\n\ttemperature?: number;\n\tpresence_penalty?: number;\n\tfrequency_penalty?: number;\n\tstop?: string[];\n\ttools?: Tools[];\n\ttool_choice?: 'auto' | 'required' | ToolChoice;\n\tparallel_tool_calls?: boolean;\n\tmessages?: Message[];\n\tvariables?: Variable[] | Record<string, string>;\n\tmemory?: {\n\t\tname: string;\n\t}[];\n\tresponse_format?: ResponseFormat;\n}\n\nexport interface PipeListResponse {\n\tname: string;\n\tdescription: string;\n\tstatus: 'public' | 'private';\n\towner_login: string;\n\turl: string;\n\tmodel: string;\n\tstream: boolean;\n\tjson: boolean;\n\tstore: boolean;\n\tmoderate: boolean;\n\ttop_p: number;\n\tmax_tokens: number;\n\ttemperature: number;\n\tpresence_penalty: number;\n\tfrequency_penalty: number;\n\tstop: string[];\n\ttool_choice: 'auto' | 'required' | ToolChoice;\n\tparallel_tool_calls: boolean;\n\tmessages: Message[];\n\tvariables: Variable[] | [];\n\ttools: Tools[] | [];\n\tmemory:\n\t\t| {\n\t\t\t\tname: string;\n\t\t  }[]\n\t\t| [];\n}\n\ninterface PipeBaseResponse {\n\tname: string;\n\tdescription: string;\n\tstatus: 'public' | 'private';\n\towner_login: string;\n\turl: string;\n\ttype: 'chat' | 'generate' | 'run';\n\tapi_key: string;\n}\n\nexport interface PipeCreateOptions extends PipeBaseOptions {}\nexport interface PipeUpdateOptions extends PipeBaseOptions {}\nexport interface PipeCreateResponse extends PipeBaseResponse {}\nexport interface PipeUpdateResponse extends PipeBaseResponse {}\n\ninterface MemoryBaseResponse {\n\tname: string;\n\tdescription: string;\n\towner_login: string;\n\turl: string;\n}\n\nexport type EmbeddingModels =\n\t| 'openai:text-embedding-3-large'\n\t| 'cohere:embed-multilingual-v3.0'\n\t| 'cohere:embed-multilingual-light-v3.0'\n\t| 'google:text-embedding-004';\n\nexport type ContentType =\n\t| 'application/pdf'\n\t| 'text/plain'\n\t| 'text/markdown'\n\t| 'text/csv'\n\t| 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n\t| 'application/vnd.ms-excel';\n\nexport interface MemoryCreateOptions {\n\tname: string;\n\tdescription?: string;\n\tembedding_model?: EmbeddingModels;\n\ttop_k?: number;\n\tchunk_size?: number;\n\tchunk_overlap?: number;\n}\n\nexport interface MemoryDeleteOptions {\n\tname: string;\n}\n\ntype FilterOperator = 'Eq' | 'NotEq' | 'In' | 'NotIn' | 'And' | 'Or';\ntype FilterConnective = 'And' | 'Or';\ntype FilterValue = string | string[];\ntype FilterCondition = [string, FilterOperator, FilterValue];\ntype MemoryFilters = [FilterConnective, MemoryFilters[]] | FilterCondition;\n\nexport interface MemoryRetrieveOptions {\n\tquery: string;\n\tmemory: {\n\t\tname: string;\n\t\tfilters?: MemoryFilters;\n\t}[];\n\ttopK?: number;\n}\n\nexport interface MemoryListDocOptions {\n\tmemoryName: string;\n}\n\nexport interface MemoryDeleteDocOptions {\n\tmemoryName: string;\n\tdocumentName: string;\n}\n\nexport interface MemoryUploadDocOptions {\n\tmemoryName: string;\n\tdocumentName: string;\n\tmeta?: Record<string, string>;\n\tdocument: Buffer | File | FormData | ReadableStream;\n\tcontentType: ContentType;\n}\n\nexport interface MemoryRetryDocEmbedOptions {\n\tmemoryName: string;\n\tdocumentName: string;\n}\n\nexport interface MemoryCreateResponse extends MemoryBaseResponse {\n\tchunk_size: number;\n\tchunk_overlap: number;\n\tembedding_model: EmbeddingModels;\n}\nexport interface MemoryListResponse extends MemoryBaseResponse {\n\tembeddingModel: EmbeddingModels;\n}\nexport interface BaseDeleteResponse {\n\tsuccess: boolean;\n}\n\nexport interface MemoryDeleteResponse extends BaseDeleteResponse {}\nexport interface MemoryDeleteDocResponse extends BaseDeleteResponse {}\nexport interface MemoryRetryDocEmbedResponse extends BaseDeleteResponse {}\n\nexport interface MemoryRetrieveResponse {\n\ttext: string;\n\tsimilarity: number;\n\tmeta: Record<string, string>;\n}\n\nexport interface MemoryListDocResponse {\n\tname: string;\n\tstatus: 'queued' | 'in_progress' | 'completed' | 'failed';\n\tstatus_message: string | null;\n\tmetadata: {\n\t\tsize: number;\n\t\ttype: ContentType;\n\t};\n\tenabled: boolean;\n\tchunk_size: number;\n\tchunk_overlap: number;\n\towner_login: string;\n}\n\nexport interface LangbaseOptions {\n\tapiKey: string;\n\tbaseUrl?: 'https://api.langbase.com' | 'https://eu-api.langbase.com';\n}\n\nexport interface ToolWebSearchOptions {\n\tquery: string;\n\tservice: 'exa';\n\ttotalResults?: number;\n\tdomains?: string[];\n\tapiKey: string;\n}\n\nexport interface ToolWebSearchResponse {\n\turl: string;\n\tcontent: string;\n}\n\nexport interface ToolCrawlOptions {\n\turl: string[];\n\tmaxPages?: number;\n\tapiKey: string;\n\tservice?: 'spider' | 'firecrawl';\n}\n\nexport interface ToolCrawlResponse {\n\turl: string;\n\tcontent: string;\n}\n\nexport interface EmbedOptions {\n\tchunks: string[];\n\tembeddingModel?: EmbeddingModels;\n}\n\nexport type EmbedResponse = number[][];\n\nexport interface ChunkOptions {\n\tcontent: string;\n\tchunkOverlap?: number;\n\tchunkMaxLength?: number;\n}\n\nexport type ChunkResponse = string[];\n\nexport type ParseOptions = {\n\tdocument: Buffer | File | FormData | ReadableStream;\n\tdocumentName: string;\n\tcontentType: ContentType;\n};\n\nexport type ParseResponse = {\n\tdocumentName: string;\n\tcontent: string;\n};\n\nexport interface ThreadsCreate {\n\tthreadId?: string;\n\tmetadata?: Record<string, string>;\n\tmessages?: ThreadMessage[];\n}\n\nexport interface ThreadsUpdate {\n\tthreadId: string;\n\tmetadata: Record<string, string>;\n}\n\nexport interface ThreadsGet {\n\tthreadId: string;\n}\n\nexport interface DeleteThreadOptions {\n\tthreadId: string;\n}\n\nexport interface ThreadsBaseResponse {\n\tid: string;\n\tobject: 'thread';\n\tcreated_at: number;\n\tmetadata: Record<string, string>;\n}\n\nexport interface ThreadMessagesCreate {\n\tthreadId: string;\n\tmessages: ThreadMessage[];\n}\n\nexport interface ThreadMessagesList {\n\tthreadId: string;\n}\n\nexport interface ThreadMessagesBaseResponse {\n\tid: string;\n\tcreated_at: number;\n\tthread_id: string;\n\tcontent: string;\n\trole: Role;\n\ttool_call_id: string | null;\n\ttool_calls: ToolCall[] | [];\n\tname: string | null;\n\tattachments: any[] | [];\n\tmetadata: Record<string, string> | {};\n}\n\ninterface ChoiceGenerate {\n\tindex: number;\n\tmessage: Message;\n\tlogprobs: boolean | null;\n\tfinish_reason: string;\n}\n\nexport class Langbase {\n\tprivate request: Request;\n\tprivate apiKey: string;\n\tprivate baseUrl: string;\n\tpublic pipes: {\n\t\tlist: () => Promise<PipeListResponse[]>;\n\t\tcreate: (options: PipeCreateOptions) => Promise<PipeCreateResponse>;\n\t\tupdate: (options: PipeUpdateOptions) => Promise<PipeUpdateResponse>;\n\t\trun: {\n\t\t\t(options: RunOptionsStream): Promise<RunResponseStream>;\n\t\t\t(options: RunOptions): Promise<RunResponse>;\n\t\t};\n\t};\n\n\t/**\n\t * @deprecated This method is deprecated and will be removed in a future version.\n\t *\n\t * Please use `langbase.pipes`\n\t */\n\tpublic pipe: {\n\t\tlist: () => Promise<PipeListResponse[]>;\n\t\tcreate: (options: PipeCreateOptions) => Promise<PipeCreateResponse>;\n\t\tupdate: (options: PipeUpdateOptions) => Promise<PipeUpdateResponse>;\n\t\trun: {\n\t\t\t(options: RunOptionsStream): Promise<RunResponseStream>;\n\t\t\t(options: RunOptions): Promise<RunResponse>;\n\t\t};\n\t};\n\n\tpublic memories: {\n\t\tcreate: (options: MemoryCreateOptions) => Promise<MemoryCreateResponse>;\n\t\tdelete: (options: MemoryDeleteOptions) => Promise<MemoryDeleteResponse>;\n\t\tretrieve: (\n\t\t\toptions: MemoryRetrieveOptions,\n\t\t) => Promise<MemoryRetrieveResponse[]>;\n\t\tlist: () => Promise<MemoryListResponse[]>;\n\t\tdocuments: {\n\t\t\tlist: (\n\t\t\t\toptions: MemoryListDocOptions,\n\t\t\t) => Promise<MemoryListDocResponse[]>;\n\t\t\tdelete: (\n\t\t\t\toptions: MemoryDeleteDocOptions,\n\t\t\t) => Promise<MemoryDeleteDocResponse>;\n\t\t\tupload: (options: MemoryUploadDocOptions) => Promise<Response>;\n\t\t\tembeddings: {\n\t\t\t\tretry: (\n\t\t\t\t\toptions: MemoryRetryDocEmbedOptions,\n\t\t\t\t) => Promise<MemoryRetryDocEmbedResponse>;\n\t\t\t};\n\t\t};\n\t};\n\n\t/**\n\t * @deprecated This method is deprecated and will be removed in a future version.\n\t *\n\t * Please use `langbase.memories`\n\t */\n\tpublic memory: {\n\t\tcreate: (options: MemoryCreateOptions) => Promise<MemoryCreateResponse>;\n\t\tdelete: (options: MemoryDeleteOptions) => Promise<MemoryDeleteResponse>;\n\t\tretrieve: (\n\t\t\toptions: MemoryRetrieveOptions,\n\t\t) => Promise<MemoryRetrieveResponse[]>;\n\t\tlist: () => Promise<MemoryListResponse[]>;\n\t\tdocuments: {\n\t\t\tlist: (\n\t\t\t\toptions: MemoryListDocOptions,\n\t\t\t) => Promise<MemoryListDocResponse[]>;\n\t\t\tdelete: (\n\t\t\t\toptions: MemoryDeleteDocOptions,\n\t\t\t) => Promise<MemoryDeleteDocResponse>;\n\t\t\tupload: (options: MemoryUploadDocOptions) => Promise<Response>;\n\t\t\tembedding: {\n\t\t\t\tretry: (\n\t\t\t\t\toptions: MemoryRetryDocEmbedOptions,\n\t\t\t\t) => Promise<MemoryRetryDocEmbedResponse>;\n\t\t\t};\n\t\t};\n\t};\n\n\tpublic threads: {\n\t\tcreate: (options: ThreadsCreate) => Promise<ThreadsBaseResponse>;\n\t\tupdate: (options: ThreadsUpdate) => Promise<ThreadsBaseResponse>;\n\t\tget: (options: ThreadsGet) => Promise<ThreadsBaseResponse>;\n\t\tdelete: (options: DeleteThreadOptions) => Promise<{success: boolean}>;\n\t\tappend: (\n\t\t\toptions: ThreadMessagesCreate,\n\t\t) => Promise<ThreadMessagesBaseResponse[]>;\n\t\tmessages: {\n\t\t\tlist: (\n\t\t\t\toptions: ThreadMessagesList,\n\t\t\t) => Promise<ThreadMessagesBaseResponse[]>;\n\t\t};\n\t};\n\n\t/**\n\t * @deprecated This method is deprecated and will be removed in a future version.\n\t *\n\t * Please use `langbase.tools`\n\t */\n\tpublic tool: {\n\t\tcrawl: (options: ToolCrawlOptions) => Promise<ToolCrawlResponse[]>;\n\t\twebSearch: (\n\t\t\toptions: ToolWebSearchOptions,\n\t\t) => Promise<ToolWebSearchResponse[]>;\n\t};\n\n\tpublic tools: {\n\t\tcrawl: (options: ToolCrawlOptions) => Promise<ToolCrawlResponse[]>;\n\t\twebSearch: (\n\t\t\toptions: ToolWebSearchOptions,\n\t\t) => Promise<ToolWebSearchResponse[]>;\n\t};\n\n\tpublic embed: (options: EmbedOptions) => Promise<EmbedResponse>;\n\tpublic chunk: (options: ChunkOptions) => Promise<ChunkResponse>;\n\tpublic chunker: (options: ChunkOptions) => Promise<ChunkResponse>;\n\tpublic parse: (options: ParseOptions) => Promise<ParseResponse>;\n\tpublic parser: (options: ParseOptions) => Promise<ParseResponse>;\n\n\tpublic agent: {\n\t\trun: {\n\t\t\t(options: AgentRunOptionsStream): Promise<RunResponseStream>;\n\t\t\t(options: AgentRunOptions): Promise<AgentRunResponse>;\n\t\t};\n\t};\n\n\tpublic workflow: (config: {debug?: boolean; name?: string}) => Workflow;\n\n\tpublic traces: {\n\t\tcreate: (trace: any) => Promise<any>;\n\t};\n\n\tconstructor(options?: LangbaseOptions) {\n\t\tthis.baseUrl = options?.baseUrl ?? 'https://api.langbase.com';\n\t\tthis.apiKey = options?.apiKey ?? '';\n\t\tthis.request = new Request({\n\t\t\tapiKey: this.apiKey,\n\t\t\tbaseUrl: this.baseUrl,\n\t\t});\n\n\t\t// Initialize pipe property with method bindings\n\t\tthis.pipe = {\n\t\t\tlist: this.listPipe.bind(this),\n\t\t\tcreate: this.createPipe.bind(this),\n\t\t\tupdate: this.updatePipe.bind(this),\n\t\t\trun: this.runPipe.bind(this),\n\t\t};\n\n\t\tthis.pipes = {\n\t\t\tlist: this.listPipe.bind(this),\n\t\t\tcreate: this.createPipe.bind(this),\n\t\t\tupdate: this.updatePipe.bind(this),\n\t\t\trun: this.runPipe.bind(this),\n\t\t};\n\n\t\t// Initialize memory property with method bindings\n\t\tthis.memory = {\n\t\t\tcreate: this.createMemory.bind(this),\n\t\t\tdelete: this.deleteMemory.bind(this),\n\t\t\tretrieve: this.retrieveMemory.bind(this),\n\t\t\tlist: this.listMemory.bind(this),\n\t\t\tdocuments: {\n\t\t\t\tlist: this.listDocs.bind(this),\n\t\t\t\tdelete: this.deleteDoc.bind(this),\n\t\t\t\tupload: this.uploadDocs.bind(this),\n\t\t\t\tembedding: {\n\t\t\t\t\tretry: this.retryDocEmbed.bind(this),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Initialize memory property with method bindings\n\t\tthis.memories = {\n\t\t\tcreate: this.createMemory.bind(this),\n\t\t\tdelete: this.deleteMemory.bind(this),\n\t\t\tretrieve: this.retrieveMemory.bind(this),\n\t\t\tlist: this.listMemory.bind(this),\n\t\t\tdocuments: {\n\t\t\t\tlist: this.listDocs.bind(this),\n\t\t\t\tdelete: this.deleteDoc.bind(this),\n\t\t\t\tupload: this.uploadDocs.bind(this),\n\t\t\t\tembeddings: {\n\t\t\t\t\tretry: this.retryDocEmbed.bind(this),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tthis.tools = {\n\t\t\tcrawl: this.webCrawl.bind(this),\n\t\t\twebSearch: this.webSearch.bind(this),\n\t\t};\n\n\t\tthis.tool = {\n\t\t\tcrawl: this.webCrawl.bind(this),\n\t\t\twebSearch: this.webSearch.bind(this),\n\t\t};\n\n\t\tthis.embed = this.generateEmbeddings.bind(this);\n\t\tthis.chunk = this.chunkDocument.bind(this);\n\t\tthis.chunker = this.chunkDocument.bind(this);\n\t\tthis.parse = this.parseDocument.bind(this);\n\t\tthis.parser = this.parseDocument.bind(this);\n\t\tthis.threads = {\n\t\t\tcreate: this.createThread.bind(this),\n\t\t\tupdate: this.updateThread.bind(this),\n\t\t\tget: this.getThread.bind(this),\n\t\t\tdelete: this.deleteThread.bind(this),\n\t\t\tappend: this.appendThreadMessages.bind(this),\n\t\t\tmessages: {\n\t\t\t\tlist: this.listThreadMessages.bind(this),\n\t\t\t},\n\t\t};\n\n\t\tthis.agent = {\n\t\t\trun: this.runAgent.bind(this),\n\t\t};\n\n\t\tthis.workflow = config => new Workflow({...config, langbase: this});\n\n\t\tthis.traces = {\n\t\t\tcreate: this.createTrace.bind(this),\n\t\t};\n\t}\n\n\tprivate async runPipe(\n\t\toptions: RunOptionsStream,\n\t): Promise<RunResponseStream>;\n\tprivate async runPipe(options: RunOptions): Promise<RunResponse>;\n\tprivate async runPipe(\n\t\toptions: RunOptions | RunOptionsStream,\n\t): Promise<RunResponse | RunResponseStream> {\n\t\tif (!options.name?.trim() && !options.apiKey) {\n\t\t\tthrow new Error(\n\t\t\t\t'Pipe name or Pipe API key is required to run the pipe.',\n\t\t\t);\n\t\t}\n\n\t\t// Remove stream property if it's not set to true\n\t\tif (typeof options.stream === 'undefined') {\n\t\t\tdelete options.stream;\n\t\t}\n\n\t\t// if apikey is provided, create a new request instance\n\t\tif (options.apiKey) {\n\t\t\tthis.request = new Request({\n\t\t\t\tapiKey: options.apiKey,\n\t\t\t\tbaseUrl: this.baseUrl,\n\t\t\t});\n\t\t}\n\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/pipes/run',\n\t\t\tbody: options,\n\t\t\theaders: {\n\t\t\t\t...(options.llmKey && {\n\t\t\t\t\t'LB-LLM-KEY': options.llmKey,\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new pipe on Langbase.\n\t *\n\t * @param {PipeCreateOptions} options - The options for creating the pipe.\n\t * @returns {Promise<PipeCreateResponse>} A promise that resolves to the response of the pipe creation.\n\t */\n\tprivate async createPipe(\n\t\toptions: PipeCreateOptions,\n\t): Promise<PipeCreateResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/pipes',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Updates a pipe on Langbase.\n\t *\n\t * @param {PipeUpdateOptions} options - The options for updating the pipe.\n\t * @returns {Promise<PipeUpdateResponse>} A promise that resolves to the response of the update operation.\n\t */\n\tprivate async updatePipe(\n\t\toptions: PipeUpdateOptions,\n\t): Promise<PipeUpdateResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: `/v1/pipes/${options.name}`,\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a list of pipes.\n\t *\n\t * @returns {Promise<PipeListResponse[]>} A promise that resolves to an array of PipeListResponse objects.\n\t */\n\tprivate async listPipe(): Promise<PipeListResponse[]> {\n\t\treturn this.request.get({\n\t\t\tendpoint: '/v1/pipes',\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new memory on Langbase.\n\t *\n\t * @param {MemoryCreateOptions} options - The options to create the memory instance.\n\t * @param {string} options.name - The name of the memory.\n\t * @param {string} options.description - The description of the memory.\n\t * @returns {Promise<MemoryCreateResponse>} A promise that resolves to the response of the memory creation.\n\t */\n\tprivate async createMemory(\n\t\toptions: MemoryCreateOptions,\n\t): Promise<MemoryCreateResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/memory',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a list of all memories on Langbase.\n\t *\n\t * @returns {Promise<MemoryListResponse[]>} A promise that resolves to an array of memory list responses.\n\t */\n\tprivate async listMemory(): Promise<MemoryListResponse[]> {\n\t\treturn this.request.get({\n\t\t\tendpoint: '/v1/memory',\n\t\t});\n\t}\n\n\t/**\n\t * Deletes a memory on Langbase.\n\t *\n\t * @param {MemoryDeleteOptions} options - The options for deleting the memory resource.\n\t * @param {string} options.name - The name of the memory to delete.\n\t * @returns {Promise<MemoryDeleteResponse>} A promise that resolves to the response of the delete operation.\n\t */\n\tprivate async deleteMemory(\n\t\toptions: MemoryDeleteOptions,\n\t): Promise<MemoryDeleteResponse> {\n\t\treturn this.request.delete({\n\t\t\tendpoint: `/v1/memory/${options.name}`,\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves similar text from the memory.\n\t *\n\t * @param {MemoryRetrieveOptions} options - The options to use for retrieving memory data.\n\t * @param {string} options.query - The query text to search for.\n\t * @param {object[]} options.memory - The memory to search in.\n\t * @param {number} [options.topK] - The number of similar texts to retrieve.\n\t * @returns A promise that resolves to an array of `MemoryRetrieveResponse` objects.\n\t */\n\tprivate async retrieveMemory(\n\t\toptions: MemoryRetrieveOptions,\n\t): Promise<MemoryRetrieveResponse[]> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/memory/retrieve',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a list of documents inside a memory.\n\t *\n\t * @param {MemoryListDocOptions} options - The options for listing documents, including the memory name.\n\t * @param {string} options.memoryName - The name of the memory to list documents from.\n\t * @returns A promise that resolves to an array of `MemoryListDocResponse` objects.\n\t */\n\tprivate async listDocs(\n\t\toptions: MemoryListDocOptions,\n\t): Promise<MemoryListDocResponse[]> {\n\t\treturn this.request.get({\n\t\t\tendpoint: `/v1/memory/${options.memoryName}/documents`,\n\t\t});\n\t}\n\n\t/**\n\t * Deletes a document from a memory.\n\t *\n\t * @param {MemoryDeleteDocOptions} options - The options for deleting the document.\n\t * @param {string} options.memoryName - The name of the memory to delete the document from.\n\t * @param {string} options.documentName - The name of the document to delete.\n\t * @returns A promise that resolves to a `MemoryDeleteDocResponse` indicating the result of the delete operation.\n\t */\n\tprivate async deleteDoc(\n\t\toptions: MemoryDeleteDocOptions,\n\t): Promise<MemoryDeleteDocResponse> {\n\t\treturn this.request.delete({\n\t\t\tendpoint: `/v1/memory/${options.memoryName}/documents/${options.documentName}`,\n\t\t});\n\t}\n\n\t/**\n\t * Uploads a document to the memory.\n\t *\n\t * @param {MemoryUploadDocOptions} options - The options for uploading the document.\n\t * @param {string} options.memoryName - The name of the memory to upload the document to.\n\t * @param {string} options.fileName - The name of the file being uploaded.\n\t * @param {object} [options.meta] - Optional metadata associated with the document.\n\t * @param {string} options.contentType - The MIME type of the file being uploaded.\n\t * @param {Blob | Buffer} options.file - The file content to be uploaded.\n\t * @returns {Promise<Response>} The response from the upload request.\n\t * @throws Will throw an error if the upload fails.\n\t */\n\tprivate async uploadDocs(\n\t\toptions: MemoryUploadDocOptions,\n\t): Promise<Response> {\n\t\ttry {\n\t\t\tconst response = (await this.request.post({\n\t\t\t\tendpoint: `/v1/memory/documents`,\n\t\t\t\tbody: {\n\t\t\t\t\tmemoryName: options.memoryName,\n\t\t\t\t\tfileName: options.documentName,\n\t\t\t\t\tmeta: options.meta,\n\t\t\t\t},\n\t\t\t})) as unknown as {signedUrl: string};\n\n\t\t\tconst uploadUrl = response.signedUrl;\n\n\t\t\treturn await fetch(uploadUrl, {\n\t\t\t\tmethod: 'PUT',\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Bearer ${this.apiKey}`,\n\t\t\t\t\t'Content-Type': options.contentType,\n\t\t\t\t},\n\t\t\t\tbody: options.document,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Retries the embedding process for a specific document in memory.\n\t *\n\t * @param options - The options required to retry the document embedding.\n\t * @param options.memoryName - The name of the memory containing the document.\n\t * @param options.documentName - The name of the document to retry embedding for.\n\t * @returns A promise that resolves to the response of the retry operation.\n\t */\n\tprivate async retryDocEmbed(\n\t\toptions: MemoryRetryDocEmbedOptions,\n\t): Promise<MemoryRetryDocEmbedResponse> {\n\t\treturn this.request.get({\n\t\t\tendpoint: `/v1/memory/${options.memoryName}/documents/${options.documentName}/embeddings/retry`,\n\t\t});\n\t}\n\n\t/**\n\t * Performs a web search using the Langbase API.\n\t *\n\t * @param options - Web search configuration options\n\t * @param options.apiKey - Optional API key for web search authentication\n\t * @returns Promise that resolves to an array of web search results\n\t */\n\tprivate async webSearch(\n\t\toptions: ToolWebSearchOptions,\n\t): Promise<ToolWebSearchResponse[]> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/tools/web-search',\n\t\t\tbody: options,\n\t\t\theaders: {\n\t\t\t\t'LB-WEB-SEARCH-KEY': options.apiKey,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Performs a web crawls on target websites using the Langbase API.\n\t *\n\t * @param options - Crawl configuration options\n\t * @returns An array of responses containing data from the crawl operation.\n\t */\n\tprivate async webCrawl(\n\t\toptions: ToolCrawlOptions,\n\t): Promise<ToolCrawlResponse[]> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/tools/crawl',\n\t\t\tbody: options,\n\t\t\theaders: {\n\t\t\t\t'LB-CRAWL-KEY': options.apiKey,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Generates embeddings for the given input using the LangBase API.\n\t *\n\t * @param options - Embed options\n\t * @returns Promise that resolves to the embedding response containing vector representations\n\t */\n\tprivate async generateEmbeddings(\n\t\toptions: EmbedOptions,\n\t): Promise<EmbedResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/embed',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Splits a given document into multiple chunks using the Langbase API.\n\t *\n\t * @param options - The chunking options.\n\t * @param options.document - The document to be chunked.\n\t * @param options.chunk_max_length - An optional maximum length for each chunk.\n\t * @param options.chunk_overlap - An optional number of overlapping characters between chunks.\n\t * @param options.separator - An optional separator used to split the document.\n\t * @returns A promise that resolves to the chunked document response.\n\t */\n\tprivate async chunkDocument(options: ChunkOptions): Promise<ChunkResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/chunker',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Parses a document using the Langbase API.\n\t *\n\t * @param options - The options for parsing the document\n\t * @param options.document - The document to be parsed\n\t * @param options.documentName - The name of the document\n\t * @param options.contentType - The content type of the document\n\t *\n\t * @returns A promise that resolves to the parse response from the API\n\t *\n\t * @throws {Error} If the API request fails\n\t */\n\tprivate async parseDocument(options: ParseOptions): Promise<ParseResponse> {\n\t\tconst formData = await convertDocToFormData({\n\t\t\tdocument: options.document,\n\t\t\tdocumentName: options.documentName,\n\t\t\tcontentType: options.contentType,\n\t\t});\n\n\t\tconst response = await fetch(`${this.baseUrl}/v1/parser`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Bearer ${this.apiKey}`,\n\t\t\t},\n\t\t\tbody: formData,\n\t\t});\n\n\t\treturn response.json();\n\t}\n\n\t/**\n\t * Creates a new thread with specified options.\n\t * @param {ThreadsCreate} options - The options object containing thread creation parameters.\n\t * @returns {Promise<ThreadsBaseResponse>} A promise that resolves to the created thread response.\n\t * @private\n\t */\n\tprivate async createThread(\n\t\toptions: ThreadsCreate,\n\t): Promise<ThreadsBaseResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/threads',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Updates an existing thread with the provided options.\n\t *\n\t * @param options - The options to update the thread with\n\t * @param options.threadId - The ID of the thread to update\n\t * @returns A promise that resolves to the updated thread response\n\t * @throws {Error} If the request fails\n\t */\n\tprivate async updateThread(\n\t\toptions: ThreadsUpdate,\n\t): Promise<ThreadsBaseResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: `/v1/threads/${options.threadId}`,\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a thread by its ID.\n\t * @param {ThreadsGet} options - The options object containing the thread ID.\n\t * @param {string} options.threadId - The unique identifier of the thread to retrieve.\n\t * @returns {Promise<ThreadsBaseResponse>} A promise that resolves to the thread data.\n\t */\n\tprivate async getThread(options: ThreadsGet): Promise<ThreadsBaseResponse> {\n\t\treturn this.request.get({\n\t\t\tendpoint: `/v1/threads/${options.threadId}`,\n\t\t});\n\t}\n\n\tprivate async deleteThread(\n\t\toptions: DeleteThreadOptions,\n\t): Promise<{success: boolean}> {\n\t\treturn this.request.delete({\n\t\t\tendpoint: `/v1/threads/${options.threadId}`,\n\t\t});\n\t}\n\n\tprivate async appendThreadMessages(\n\t\toptions: ThreadMessagesCreate,\n\t): Promise<ThreadMessagesBaseResponse[]> {\n\t\treturn this.request.post({\n\t\t\tendpoint: `/v1/threads/${options.threadId}/messages`,\n\t\t\tbody: options.messages,\n\t\t});\n\t}\n\n\tprivate async listThreadMessages(\n\t\toptions: ThreadMessagesList,\n\t): Promise<ThreadMessagesBaseResponse[]> {\n\t\treturn this.request.get({\n\t\t\tendpoint: `/v1/threads/${options.threadId}/messages`,\n\t\t});\n\t}\n\n\t// Add the private implementation\n\tprivate async runAgent(\n\t\toptions: AgentRunOptionsStream,\n\t): Promise<RunResponseStream>;\n\n\tprivate async runAgent(options: AgentRunOptions): Promise<AgentRunResponse>;\n\n\tprivate async runAgent(\n\t\toptions: AgentRunOptions | AgentRunOptionsStream,\n\t): Promise<AgentRunResponse | RunResponseStream> {\n\t\tif (!options.apiKey) {\n\t\t\tthrow new Error('LLM API key is required to run this LLM.');\n\t\t}\n\n\t\t// Remove stream property if it's not set to true\n\t\tif (typeof options.stream === 'undefined') {\n\t\t\tdelete options.stream;\n\t\t}\n\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/agent/run',\n\t\t\tbody: options,\n\t\t\theaders: {\n\t\t\t\t...(options.apiKey && {'LB-LLM-Key': options.apiKey}),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new trace on Langbase.\n\t *\n\t * @param {any} trace - The trace data to send.\n\t * @returns {Promise<any>} A promise that resolves to the response of the trace creation.\n\t */\n\tprivate async createTrace(trace: any): Promise<any> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/traces',\n\t\t\tbody: trace,\n\t\t});\n\t}\n}\n","import {Message, Role, ToolCall, Usage, Variable} from '@/langbase/langbase';\nimport {Request} from '../common/request';\nimport {Stream} from '../common/stream';\n\nexport interface GenerateOptions {\n\tmessages?: Message[];\n\tvariables?: Variable[];\n\tthreadId?: string;\n\tchat?: boolean;\n}\n\nexport interface StreamOptions {\n\tmessages?: Message[];\n\tvariables?: Variable[];\n\tthreadId?: string | null;\n\tchat?: boolean;\n}\n\ninterface ChoiceGenerate {\n\tindex: number;\n\tmessage: Message;\n\tlogprobs: boolean | null;\n\tfinish_reason: string;\n}\n\ninterface ChoiceStream {\n\tindex: number;\n\tdelta: Delta;\n\tlogprobs: boolean | null;\n\tfinish_reason: string;\n}\n\ninterface Delta {\n\trole?: Role;\n\tcontent?: string;\n\ttool_calls?: ToolCall[];\n}\n\nexport interface GenerateResponse {\n\tcompletion: string;\n\tthreadId?: string;\n\tid: string;\n\tobject: string;\n\tcreated: number;\n\tmodel: string;\n\tchoices: ChoiceGenerate[];\n\tusage: Usage;\n\tsystem_fingerprint: string | null;\n}\n\nexport type StreamText = Stream<StreamChunk>;\n\nexport interface StreamResponse {\n\tstream: StreamText;\n\tthreadId: string | null;\n}\n\nexport interface StreamChunk {\n\tid: string;\n\tobject: string;\n\tcreated: number;\n\tmodel: string;\n\tchoices: ChoiceStream[];\n}\n\nexport interface PipeOptions {\n\tapiKey: string;\n\tbaseUrl?: string;\n\tname?: string;\n}\n\nexport class Pipe {\n\tprivate request: Request;\n\n\tconstructor(options: PipeOptions) {\n\t\tconst baseUrl = 'https://api.langbase.com';\n\t\tthis.request = new Request({apiKey: options.apiKey, baseUrl});\n\t}\n\n\t/**\n\t * @deprecated This method is deprecated and will be removed in a future version.\n\t *\n\t * Please use `langbase.pipes.run()` instead\n\t * @see https://langbase.com/docs/sdk/pipe/run\n\t */\n\tasync generateText(options: GenerateOptions): Promise<GenerateResponse> {\n\t\treturn this.request.post<GenerateResponse>({\n\t\t\tendpoint: options.chat ? '/beta/chat' : '/beta/generate',\n\t\t\tbody: {...options, stream: false},\n\t\t});\n\t}\n\n\t/**\n\t * @deprecated This method is deprecated and will be removed in a future version.\n\t *\n\t * Please use `langbase.pipes.run()` instead\n\t * @see https://langbase.com/docs/sdk/pipe/run\n\t */\n\tasync streamText(options: StreamOptions): Promise<StreamResponse> {\n\t\treturn this.request.post<StreamResponse>({\n\t\t\tendpoint: options.chat ? '/beta/chat' : '/beta/generate',\n\t\t\tbody: {...options, stream: true},\n\t\t});\n\t}\n}\n\n/**\n * Print stream to standard output (console).\n * @param stream The stream to print\n */\nexport const printStreamToStdout = async (\n\tstream: StreamText,\n): Promise<void> => {\n\tfor await (const chunk of stream) {\n\t\tconst textPart = chunk.choices[0]?.delta?.content || '';\n\t\tprocess.stdout.write(textPart);\n\t}\n};\n","import {ChatCompletionStream} from 'openai/lib/ChatCompletionStream';\nimport {Stream} from 'openai/streaming';\nimport {ChatCompletionMessageToolCall} from 'openai/resources/chat/completions';\nimport {RunResponse, RunResponseStream} from '@/langbase/langbase';\n\nexport interface Runner extends ChatCompletionStream {}\n\nexport interface ToolCallResult extends ChatCompletionMessageToolCall {}\n\nexport type MessageRole = 'function' | 'assistant' | 'system' | 'user' | 'tool';\n\ninterface Delta {\n\trole?: MessageRole;\n\tcontent?: string;\n\ttool_calls?: ToolCallResult[];\n}\n\ninterface ChoiceStream {\n\tindex: number;\n\tdelta: Delta;\n\tlogprobs: boolean | null;\n\tfinish_reason: string;\n}\n\nexport interface ChunkStream {\n\tid: string;\n\tobject: string;\n\tcreated: number;\n\tmodel: string;\n\tchoices: ChoiceStream[];\n}\n\n/**\n * Converts a ReadableStream into a Runner.\n *\n * @param readableStream - The ReadableStream to convert.\n * @returns The converted Runner.\n */\nexport const fromReadableStream = (readableStream: ReadableStream): Runner => {\n\treturn ChatCompletionStream.fromReadableStream(readableStream);\n};\n\n/**\n * Returns a runner for the given readable stream.\n *\n * @param readableStream - The readable stream to create a runner for.\n * @returns A runner for the given readable stream.\n */\nexport const getRunner = (readableStream: ReadableStream) => {\n\treturn fromReadableStream(readableStream);\n};\n\n/**\n * Retrieves the text part from a given ChunkStream.\n *\n * @param chunk - The ChunkStream object.\n * @returns The text content of the first choice's delta, or an empty string if it doesn't exist.\n */\nexport const getTextPart = (chunk: ChunkStream) => {\n\treturn chunk.choices[0]?.delta?.content || '';\n};\n\n/**\n * Handles the response stream from a given `Response` object.\n *\n * @param {Object} params - The parameters for handling the response stream.\n * @param {Response} params.response - The API response to handle.\n * @param {boolean} params.rawResponse - Optional flag to include raw response headers.\n *\n * @returns {Object} An object containing the processed stream, thread ID, and optionally raw response headers.\n * @returns {ReadableStream<any>} return.stream - The readable stream created from the response.\n * @returns {string | null} return.threadId - The thread ID extracted from the response headers.\n * @returns {Object} [return.rawResponse] - Optional raw response headers.\n * @returns {Record<string, string>} return.rawResponse.headers - The headers from the raw response.\n */\nexport function handleResponseStream({\n\tresponse,\n\trawResponse,\n}: {\n\tresponse: Response;\n\trawResponse?: boolean;\n}): {\n\tstream: any;\n\tthreadId: string | null;\n\trawResponse?: {\n\t\theaders: Record<string, string>;\n\t};\n} {\n\tconst controller = new AbortController();\n\tconst streamSSE = Stream.fromSSEResponse(response, controller);\n\tconst stream = streamSSE.toReadableStream();\n\n\tconst result: {\n\t\tstream: ReadableStream<any>;\n\t\tthreadId: string | null;\n\t\trawResponse?: {\n\t\t\theaders: Record<string, string>;\n\t\t};\n\t} = {\n\t\tstream,\n\t\tthreadId: response.headers.get('lb-thread-id'),\n\t};\n\tif (rawResponse) {\n\t\tresult.rawResponse = {\n\t\t\theaders: Object.fromEntries(response.headers.entries()),\n\t\t};\n\t}\n\treturn result;\n}\n\n/**\n * Retrieves tool calls from a given readable stream.\n *\n * @param stream - The readable stream from which to extract tool calls.\n * @returns A promise that resolves to an array of `ToolCall` objects.\n */\nexport async function getToolsFromStream(\n\tstream: ReadableStream<any>,\n): Promise<ChatCompletionMessageToolCall[]> {\n\tlet run = getRunner(stream);\n\tconst {choices} = await run.finalChatCompletion();\n\tconst tools = choices[0].message.tool_calls;\n\treturn tools ?? [];\n}\n\n/**\n * Retrieves tools from a readable stream asynchronously.\n *\n * @param stream - The readable stream to extract tools from\n * @returns A promise that resolves with the tools extracted from the stream\n */\nexport async function getToolsFromRunStream(stream: ReadableStream<any>) {\n\treturn getToolsFromStream(stream);\n}\n\n/**\n * Extracts tool calls from non-stream response.\n * @param response - The run response object\n * @returns A promise that resolves to an array of tool calls. Returns empty array if no tools are present.\n */\nexport async function getToolsFromRun(\n\tresponse: RunResponse,\n): Promise<ChatCompletionMessageToolCall[]> {\n\tconst tools = response.choices[0].message.tool_calls;\n\treturn tools ?? [];\n}\n"],"mappings":"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","names":["self"]}