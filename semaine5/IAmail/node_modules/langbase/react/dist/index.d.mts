import React from 'react';

type Role = 'user' | 'assistant' | 'system' | 'tool';
interface Function {
    name: string;
    arguments: string;
}
interface ToolCall {
    id: string;
    type: 'function';
    function: Function;
}
interface Message {
    role: Role;
    content: string | null;
    name?: string;
    tool_call_id?: string;
    tool_calls?: ToolCall[];
}

interface PipeRequestOptions {
    headers?: Record<string, string> | Headers;
    body?: any;
    data?: any;
    allowEmptySubmit?: boolean;
}
interface UsePipeOptions {
    apiRoute?: string;
    onResponse?: (message: Message) => void;
    onFinish?: (messages: Message[], threadId: string) => void;
    onConnect?: () => void;
    onError?: (error: Error) => void;
    onCancel?: (messages: Message[]) => void;
    threadId?: string;
    initialMessages?: Message[];
    stream?: boolean;
}
declare function usePipe({ apiRoute, onResponse, onFinish, onConnect, onError, threadId: initialThreadId, initialMessages, stream, onCancel, }?: UsePipeOptions): {
    messages: Message[];
    input: string;
    handleInputChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
    handleSubmit: (event?: {
        preventDefault?: () => void;
    }, options?: PipeRequestOptions) => Promise<void>;
    isLoading: boolean;
    error: Error | null;
    regenerate: (options?: PipeRequestOptions) => Promise<void>;
    stop: () => void;
    setMessages: (newMessages: Message[]) => void;
    threadId: string | undefined;
    sendMessage: (content: string, options?: PipeRequestOptions) => Promise<void>;
    setInput: React.Dispatch<React.SetStateAction<string>>;
    setThreadId: (newThreadId: string | undefined) => void;
};

export { usePipe };
